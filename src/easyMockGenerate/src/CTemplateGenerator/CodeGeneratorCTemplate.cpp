/*! \file
 *
 * \brief See CodeGeneratorCTemplate.hpp
 */
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <cstring>
#include "CodeGeneratorCTemplate.h"
#include <boost/filesystem.hpp>
#include <boost/algorithm/string/replace.hpp>
#include <unordered_set>

#include <sys/stat.h>
#include <fcntl.h>

#include "TypeItf.h"
#include "ComposableType.h"
#include "Pointer.h"
#include "FunctionDeclaration.h"
#include "FunctionType.h"
#include "ComposableFieldItf.h"
#include "ComposableField.h"
#include "ComposableBitfield.h"
#include "QualifiedType.h"
#include "IncompleteType.h"
#include "Enum.h"
#include "TypedefType.h"

#undef NDEBUG
#include <cassert>

/*!
 * \brief Defines a new CTemplate variable.
 */
#define TEMPLATE_VAR(VAR_NAME) "{{" VAR_NAME "}}"
/*!
 * \brief Defines the beginning of a CTemplate section.
 */
#define TEMPLATE_BEG_SECTION(SECTION_NAME) "{{#" SECTION_NAME "}}"
/*!
 * \brief Defines the end of a CTemplate section.
 */
#define TEMPLATE_END_SECTION(SECTION_NAME) "{{/" SECTION_NAME "}}"
/*!
 * \brief Defines a CTemplate section which can be included recursively.
 */
#define TEMPLATE_INCL_SECTION(SECTION_NAME) "{{>" SECTION_NAME "}}"

#define MOCK_FRAMEWORK_NAME "easyMock"
#define MOCK_FRAMEWORK_NAME_UPPER "EASYMOCK"
#define MOCK_OUT_PREFIX "out_"

#define CARRIAGE_RETURN "\n"

#define MOCKED_HEADER_FILENAME "MOCKED_HEADER_FILENAME"
#define MOCKED_FILE_NAME_WITHOUT_EXT_UPPER "MOCKED_FILE_NAME_WITHOUT_EXT_UPPER"
#define FUNCTION_SECTION "FUNCTION_SECTION"
#define FUNCTION_PARAM_SECTION "FUNCTION_PARAM_SECTION"
#define FUNCTION_PARAM_PTR_SECTION "FUNCTION_PARAM_PTR_SECTION"
#define FUNCTION_VOID_PTR_OUT_SECTION "FUNCTION_VOID_PTR_OUT_SECTION"
#define FUNCTION_NON_VOID_PTR_OUT_SECTION "FUNCTION_NON_VOID_PTR_OUT_SECTION"
#define COMPOSED_TYPE_COMPARE_SECTION "COMPOSED_TYPE_COMPARE_SECTION"
#define STRUCT_COMPARE_PRE_IF_SECTION "STRUCT_COMPARE_PRE_IF_SECTION"
#define STRUCT_COMPARE_PRE_IF_SECTION_VAR_NAME "STRUCT_COMPARE_PRE_IF_SECTION_VAR_NAME"
#define STRUCT_COMPARE_PRE_IF_SECTION_FIELD_NAME "STRUCT_COMPARE_PRE_IF_SECTION_FIELD_NAME"
#define COMPOSED_TYPED_DECL_STRING "COMPOSED_TYPED_DECL_STRING"
#define COMPOSED_TYPED_UNIQUE_NAME "COMPOSED_TYPED_UNIQUE_NAME"
#define STRUCT_COMPARE_PARAM_SECTION "STRUCT_COMPARE_PARAM_SECTION"
#define STRUCT_COMPARE_ARRAY_SECTION "STRUCT_COMPARE_ARRAY_SECTION"
#define STRUCT_PRINT_IDX_SECTION "STRUCT_PRINT_IDX_SECTION"
#define COMPARE_CONDITION "COMPARE_CONDITION"
#define STRUCT_COMPARE_ERROR "STRUCT_COMPARE_ERROR"
#define STRUCT_COMPARE_FIELD "STRUCT_COMPARE_FIELD"
#define STRUCT_COMPARE_TYPE "STRUCT_COMPARE_TYPE"
#define STRUCT_COMPARE_PRINTF_FORMAT "STRUCT_COMPARE_PRINTF_FORMAT"
#define FUNCTION_PARAM_SECTION_SEPARATOR FUNCTION_PARAM_SECTION "_separator"
#define FUNCTION_PARAM_PTR_SECTION_SEPARATOR FUNCTION_PARAM_PTR_SECTION "_separator"
#define FUNCTION_PARAM_TYPE "FUNCTION_PARAM_TYPE"
#define FUNCTION_PARAM_NON_QUALIFIED_TYPE "FUNCTION_PARAM_NON_QUALIFIED_TYPE"
#define FUNCTION_PARAM_NAME "TYPEDEF_PARAM_NAME"
#define FUNCTION_MATCHER_PARAM_NAME "FUNCTION_MATCHER_PARAM_NAME"
#define FUNCTION_RETURN_VALUE_PARAM_SECTION "FUNCTION_RETURN_VALUE_PARAM_SECTION"
#define FUNCTION_RETURN_VALUE_PARAM "FUNCTION_RETURN_VALUE_PARAM"
#define FUNCTION_RETURN_VALUE "FUNCTION_RETURN_VALUE"
#define FUNCTION_TO_RETURN_VALUE "FUNCTION_TO_RETURN_VALUE"
#define FUNCTION_STACK_VARIABLE_NAME "FUNCTION_NAME"
#define FUNCTION_NAME_UPPER "FUNCTION_NAME_UPPER"
#define FUNCTION_MATCHER_LIST_SECTION "FUNCTION_MATCHER_LIST_SECTION"
#define FUNCTION_PARAM_LIST_SECTION "FUNCTION_PARAM_LIST_SECTION"
#define FUNCTION_PARAM_PTR_LIST_SECTION "FUNCTION_PARAM_PTR_LIST_SECTION"
#define NON_TYPED_DEF_COMPOSED_TYPE_SECTION "NON_TYPED_DEF_COMPOSED_TYPE_SECTION"

#define FUNCTION_ATTR_LIST_SECTION "FUNCTION_ATTR_LIST_SECTION"
#define FUNCTION_ATTR_LIST_SECTION_SEPARATOR FUNCTION_ATTR_LIST_SECTION "_separator"
#define FUNCTION_ATTR_NAME_VAR "FUNCTION_ATTR_NAME_VAR"
#define FUNCTION_ATTR_NAME_TEMPLATE_VAR TEMPLATE_VAR(FUNCTION_ATTR_NAME_VAR)

#define FUNCTION_ATTR_PARAMETER_SECTION "FUNCTION_ATTR_PARAMETER_SECTION"
#define FUNCTION_ATTR_PARAMETER_LIST "FUNCTION_ATTR_PARAMETER_LIST"
#define FUNCTION_ATTR_PARAMETER_LIST_SEPARATOR FUNCTION_ATTR_PARAMETER_LIST "_separator"

#define COMPOSED_TYPE_VAR "COMPOSED_TYPE_VAR" //struct or union
#define COMPOSED_TYPE_TEMPLATE_VAR TEMPLATE_VAR(COMPOSED_TYPE_VAR)

#define COMPOSABLE_TYPE_DECLARE_TYPE_FIELD_OR_COMPOSABLE_TYPE_FIELD_SECTION "COMPOSABLE_TYPE_DECLARE_TYPE_FIELD_OR_COMPOSABLE_TYPE_FIELD_SECTION"
#define COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_SECTION "COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_SECTION"
#define COMPOSABLE_TYPE_TYPEDEF_SECTION "COMPOSABLE_TYPE_TYPEDEF_SECTION"
#define COMPOSABLE_TYPE_INLINE_DECL_FIELD_NAME_SECTION "COMPOSABLE_TYPE_INLINE_DECL_FIELD_NAME_SECTION"
#define COMPOSABLE_TYPE_BODY_SECTION "COMPOSABLE_TYPE_BODY_SECTION"

#define COMPOSABLE_TYPE_DECLARATION_TYPE_VAR "COMPOSABLE_TYPE_DECLARATION_TYPE_VAR"
#define COMPOSABLE_TYPE_DECLARATION_TYPE_TEMPLATE_VAR TEMPLATE_VAR(COMPOSABLE_TYPE_DECLARATION_TYPE_VAR)
#define COMPOSABLE_TYPE_TYPE_NAME_VAR "COMPOSABLE_TYPE_TYPE_NAME_VAR"
#define COMPOSABLE_TYPE_TYPE_NAME_TEMPLATE_VAR TEMPLATE_VAR(COMPOSABLE_TYPE_TYPE_NAME_VAR)
#define COMPOSABLE_TYPE_INLINE_DECL_FIELD_NAME_VAR "COMPOSABLE_TYPE_INLINE_DECL_FIELD_NAME_VAR"
#define COMPOSABLE_TYPE_INLINE_DECL_FIELD_NAME_TEMPLATE_VAR TEMPLATE_VAR(COMPOSABLE_TYPE_INLINE_DECL_FIELD_NAME_VAR)

#define GENERATED_TYPE_SECTION "GENERATED_TYPE_SECTION"
#define GENERATED_TYPE_DECLARE_TYPE_SECTION "GENERATED_TYPE_DECLARE_TYPE_SECTION"
#define GENERATED_TYPE_DECLARE_TYPE_VAR "GENERATED_TYPE_DECLARE_TYPE_VAR"
#define GENERATED_TYPE_DECLARE_TYPE_TEMPLATE_VAR TEMPLATE_VAR(GENERATED_TYPE_DECLARE_TYPE_VAR)
#define GENERATED_TYPE_DECLARE_TYPENAME_VAR "GENERATED_TYPE_TYPENAME_VAR"
#define GENERATED_TYPE_DECLARE_TYPENAME_TEMPLATE_VAR TEMPLATE_VAR(GENERATED_TYPE_DECLARE_TYPENAME_VAR)
#define GENERATED_TYPE_DECLARE_MACRO_GUARD_NAME MOCK_FRAMEWORK_NAME_UPPER "_" GENERATED_TYPE_DECLARE_TYPENAME_TEMPLATE_VAR "_GENERATED"

#define GENERATED_TYPE_FORWARD_DECLARATION_SECTION "GENERATED_TYPE_FORWARD_DECLARATION_SECTION"
#define GENERATED_TYPE_FORWARD_DECLARATION_GUARD_NAME MOCK_FRAMEWORK_NAME_UPPER "_" COMPOSABLE_TYPE_DECLARATION_TYPE_TEMPLATE_VAR "_" COMPOSABLE_TYPE_TYPE_NAME_TEMPLATE_VAR "_FORWARD_GENERATED"

#define GENERATED_MACRO_SECTION "GENERATED_MACRO_SECTION"
#define GENERATED_MACRO_ID_VAR "GENERATED_MACRO_ID_VAR"
#define GENERATED_MACRO_ID_TEMPLATE_VAR TEMPLATE_VAR(GENERATED_MACRO_ID_VAR)
#define GENERATED_MACRO_PARAMETERS_SECTION "GENERATED_MACRO_PARAMETERS_SECTION"
#define GENERATED_MACRO_PARAMETERS_VAR "GENERATED_MACRO_PARAMETERS_VAR"
#define GENERATED_MACRO_PARAMETERS_TEMPLATE_VAR TEMPLATE_VAR(GENERATED_MACRO_PARAMETERS_VAR)
#define GENERATED_MACRO_DEFINITION_SECTION "GENERATED_MACRO_DEFINITION_SECTION"
#define GENERATED_MACRO_DEFINITION_VAR "GENERATED_MACRO_DEFINITION_VAR"
#define GENERATED_MACRO_DEFINITION_TEMPLATE_VAR TEMPLATE_VAR(GENERATED_MACRO_DEFINITION_VAR)

#define GENERATED_TYPE_SIMPLE_TYPEDEF_SECTION "GENERATED_TYPE_SIMPLE_TYPEDEF_SECTION"
#define GENERATED_TYPE_SIMPLE_TYPEDEF_GUARD_NAME_NAME "GENERATED_TYPE_SIMPLE_TYPEDEF_GUARD_NAME_NAME"
#define GENERATED_TYPE_SIMPLE_TYPEDEF_GUARD_NAME_NAME_VAR TEMPLATE_VAR(GENERATED_TYPE_SIMPLE_TYPEDEF_GUARD_NAME_NAME)
#define GENERATED_TYPE_SIMPLE_TYPEDEF_TYPEE_VAR "GENERATED_TYPE_SIMPLE_TYPEDEF_TYPEE_VAR"
#define GENERATED_TYPE_SIMPLE_TYPEDEF_TYPEE_TEMPLATE_VAR TEMPLATE_VAR(GENERATED_TYPE_SIMPLE_TYPEDEF_TYPEE_VAR)
#define GENERATED_TYPE_SIMPLE_TYPEDEF_TYPED_VAR "GENERATED_TYPE_SIMPLE_TYPEDEF_TYPED_VAR"
#define GENERATED_TYPE_SIMPLE_TYPEDEF_TYPED_TEMPLATE_VAR TEMPLATE_VAR(GENERATED_TYPE_SIMPLE_TYPEDEF_TYPED_VAR)
#define GENERATED_TYPE_SIMPLE_TYPEDEF_GUARD_NAME MOCK_FRAMEWORK_NAME_UPPER "_" GENERATED_TYPE_SIMPLE_TYPEDEF_GUARD_NAME_NAME_VAR "_GENERATED"

#define GENERATED_TYPE_ENUM_SECTION "GENERATED_TYPE_ENUM_SECTION"
#define GENERATED_TYPE_ENUM_NAME_VAR "GENERATED_TYPE_ENUM_NAME_VAR"
#define GENERATED_TYPE_ENUM_NAME_TEMPLATE_VAR TEMPLATE_VAR(GENERATED_TYPE_ENUM_NAME_VAR)
#define GENERATED_TYPE_ENUM_VALUE_SECTION "GENERATED_TYPE_ENUM_VALUE_SECTION"
#define GENERATED_TYPE_ENUM_VALUE_NAME_VAR "GENERATED_TYPE_ENUM_VALUE_NAME_VAR"
#define GENERATED_TYPE_ENUM_VALUE_NAME_TEMPLATE_VAR TEMPLATE_VAR("GENERATED_TYPE_ENUM_VALUE_NAME_VAR")
#define GENERATED_TYPE_ENUM_VALUE_VALUE_VAR "GENERATED_TYPE_ENUM_VALUE_VALUE_VAR"
#define GENERATED_TYPE_ENUM_VALUE_VALUE_TEMPLATE_VAR TEMPLATE_VAR("GENERATED_TYPE_ENUM_VALUE_VALUE_VAR")
#define GENERATED_TYPE_ENUM_GUARD_NAME MOCK_FRAMEWORK_NAME_UPPER "_" GENERATED_TYPE_ENUM_NAME_TEMPLATE_VAR "_GENERATED"

#define COMPOSABLE_TYPE_DECLARE_TYPE_SECTION "COMPOSABLE_TYPE_DECLARE_TYPE_SECTION"
#define TYPE_DECLARATION_VAR "TYPE_DECLARATION_VAR"
#define TYPE_DECLARATION_TEMPLATE_VAR TEMPLATE_VAR(TYPE_DECLARATION_VAR)
#define TYPE_NAME_VAR "TYPE_NAME_VAR"
#define TYPE_NAME_TEMPLATE_VAR TEMPLATE_VAR(TYPE_NAME_VAR)

#define ORIGIN_FILE_VAR "ORIGIN_FILE_VAR"
#define ORIGIN_FILE_TEMPLATE_VAR TEMPLATE_VAR(ORIGIN_FILE_VAR)

#define CFILE_TEMPLATE "CFILE_TEMPLATE"
#define HFILE_TEMPLATE "HFILE_TEMPLATE"
#define GENERATED_TYPE_DECLARE_TYPE_OR_COMPOSABLE_TYPE_TEMPLATE_NAME "GENERATED_TYPE_DECLARE_TYPE_OR_COMPOSABLE_TYPE_TEMPLATE_NAME"
#define COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_TEMPLATE_NAME "COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_TEMPLATE_NAME"
#define COMPOSABLE_TYPE_DECLARE_TYPE_FIELD_OR_COMPOSABLE_TYPE_FIELD_TEMPLATE_NAME "COMPOSABLE_TYPE_DECLARE_TYPE_FIELD_OR_COMPOSABLE_TYPE_FIELD_TEMPLATE_NAME"
#define EXTRA_DECL_TEMPLATE_NAME "EXTRA_DECL_TEMPLATE_NAME"
#define EXTRA_TOP_DECL_TEMPLATE_NAME "EXTRA_TOP_DECL_TEMPLATE_NAME"

#define VARIADIC_SECTION "VARIADIC_SECTION"
#define VARIADIC_VAR "VARIADIC_VAR"
#define VARIADIC_TEMPLATE_VAR TEMPLATE_VAR(VARIADIC_VAR)

#define EXTRA_DECL_SECTION "EXTRA_DECL_SECTION"
#define EXTRA_TOP_LEVEL_DECL_SECTION "EXTRA_TOP_LEVEL_DECL_SECTION"

#define VOID_FUNCTION_RETURN_VALUE "void"

#define INCLUDE_MOCKED_HEADER_SECTION "INCLUDE_MOCKED_HEADER_SECTION"
#define GENERATE_MOCKED_TYPE_SECTION "GENERATE_MOCKED_TYPE_SECTION"

#define GENERATE_USED_TYPE_SECTION "GENERATE_USED_TYPE_SECTION"

/*!
 * \brief Add STR_TO_PRINT into the code if the function being mocked
 * has a return value.
 *
 * This macro must be used within a FUNCTION_SECTION section
 */
#define IF_RETURN_VALUE(STR_TO_PRINT) \
  TEMPLATE_BEG_SECTION(FUNCTION_RETURN_VALUE_PARAM_SECTION) \
  STR_TO_PRINT \
  TEMPLATE_END_SECTION(FUNCTION_RETURN_VALUE_PARAM_SECTION)

/*!
 * \brief add STR_TO_PRINT if the SECTION given as parameter to this macro
 * exists.
 *
 * See the value above
 */
#define IF_SECTION_EXISTS(SECTION, STR_TO_PRINT) \
  TEMPLATE_BEG_SECTION(SECTION) \
  STR_TO_PRINT \
  TEMPLATE_END_SECTION(SECTION)

#define PARAMETER_NAME(PREFIX) PREFIX TEMPLATE_VAR(FUNCTION_PARAM_NAME)
#define MATCHER_NAME TEMPLATE_VAR(FUNCTION_MATCHER_PARAM_NAME)
#define PARAMETER_OUT_SIZE_VAR PARAMETER_NAME(MOCK_OUT_PREFIX) "_size"
#define PARAMETER_TYPE TEMPLATE_VAR(FUNCTION_PARAM_TYPE)
#define PARAMETER_NON_QUALIFIED_TYPE TEMPLATE_VAR(FUNCTION_PARAM_NON_QUALIFIED_TYPE)
#define FUNCTION_RETURN_VALUE_TYPE TEMPLATE_VAR(FUNCTION_RETURN_VALUE)
#define FUNCTION_TO_RETURN_VALUE_TYPE TEMPLATE_VAR(FUNCTION_TO_RETURN_VALUE)

#define FUNCTION_NON_QUALIFIED_RETURN_VALUE "FUNCTION_NON_QUALIFIED_RETURN_VALUE"
#define FUNCTION_NON_QUALIFIED_RETURN_VALUE_TYPE TEMPLATE_VAR(FUNCTION_NON_QUALIFIED_RETURN_VALUE)

#define PRINT_CMP_ARRAY_IDX \
  IF_SECTION_EXISTS(STRUCT_PRINT_IDX_SECTION, "at idx == %d")

#define PRINT_CMP_ARRAY_IDX_value \
  IF_SECTION_EXISTS(STRUCT_PRINT_IDX_SECTION, ", idx")

#define DECLARE_PARAMETER(PREFIX) \
PARAMETER_TYPE " " PARAMETER_NAME(PREFIX) TEMPLATE_INCL_SECTION(EXTRA_DECL_SECTION)

#define DECLARE_NON_QUALIFIED_PARAMETER(PREFIX) \
PARAMETER_NON_QUALIFIED_TYPE " " PARAMETER_NAME(PREFIX) TEMPLATE_INCL_SECTION(EXTRA_DECL_SECTION)

/*!
 * \brief Helper macro to print all declaration of the parameters of a
 * function to be mocked, a *_expectAndReturn function or *_expectReturnAndOutput case.
 *
 * The FUNCTION_VOID_PTR_OUT_SECTION is only added in the case of a
 * *_expectReturnAndOutput case.
 */
#define FUNCTION_PARAM_LIST(SECTION, PREFIX) \
  TEMPLATE_BEG_SECTION(SECTION) \
    DECLARE_PARAMETER(PREFIX) \
    IF_SECTION_EXISTS(FUNCTION_VOID_PTR_OUT_SECTION, ", easyMock_size_t " PARAMETER_OUT_SIZE_VAR) \
    TEMPLATE_BEG_SECTION(SECTION ## _SEPARATOR) \
      ", " \
    TEMPLATE_END_SECTION(SECTION ## _SEPARATOR) \
  TEMPLATE_END_SECTION(SECTION)

/*!
 * \brief Helper macro to print the parameters of a call to a *_expectAndReturn
 * function.
 */
#define FUNCTION_PARAM_CALL(SECTION, PREFIX) \
  TEMPLATE_BEG_SECTION(SECTION) \
    PARAMETER_NAME(PREFIX) \
    IF_SECTION_EXISTS(FUNCTION_VOID_PTR_OUT_SECTION, ", " PARAMETER_OUT_SIZE_VAR) \
    TEMPLATE_BEG_SECTION(SECTION ## _SEPARATOR) \
      ", " \
    TEMPLATE_END_SECTION(SECTION ## _SEPARATOR) \
  TEMPLATE_END_SECTION(SECTION)

#define FUNCTION_ATTRIBUTE_DECLARATION_LIST \
  TEMPLATE_BEG_SECTION(FUNCTION_ATTR_LIST_SECTION) \
    "__attribute__((" \
    FUNCTION_ATTR_NAME_TEMPLATE_VAR \
    IF_SECTION_EXISTS(FUNCTION_ATTR_PARAMETER_SECTION, "(" FUNCTION_PARAM_CALL(FUNCTION_ATTR_PARAMETER_LIST, "") ")") \
    ")) " \
    TEMPLATE_BEG_SECTION(FUNCTION_ATTR_LIST_SECTION_SEPARATOR) \
      " " \
    TEMPLATE_END_SECTION(FUNCTION_ATTR_LIST_SECTION_SEPARATOR) \
  TEMPLATE_END_SECTION(FUNCTION_ATTR_LIST_SECTION)

/*!
 * \brief Helper macro to print the parameters of a call to a
 * *_expectReturnAndOutput function with harcoded output values.
 * function.
 */
#define FUNCTION_HARDCODED_PARAM_CALL(SECTION, VALUE)\
  TEMPLATE_BEG_SECTION(SECTION) \
    VALUE \
    IF_SECTION_EXISTS(FUNCTION_VOID_PTR_OUT_SECTION, ", 0") \
    TEMPLATE_BEG_SECTION(SECTION ## _SEPARATOR) \
      ", " \
    TEMPLATE_END_SECTION(SECTION ## _SEPARATOR) \
  TEMPLATE_END_SECTION(SECTION)

#define FUNCTION_PARAM_MATCH_VAR \
"easyMock_match_" MATCHER_NAME

#define FUNCTION_MATCHER_LIST \
  TEMPLATE_BEG_SECTION(FUNCTION_PARAM_SECTION) \
    "EasyMock_Matcher " FUNCTION_PARAM_MATCH_VAR \
    TEMPLATE_BEG_SECTION(FUNCTION_PARAM_SECTION_SEPARATOR)\
      ", " \
    TEMPLATE_END_SECTION(FUNCTION_PARAM_SECTION_SEPARATOR) \
  TEMPLATE_END_SECTION(FUNCTION_PARAM_SECTION)

#define FUNCTION_MATCHER_CALL \
  TEMPLATE_BEG_SECTION(FUNCTION_PARAM_SECTION) \
    FUNCTION_PARAM_MATCH_VAR \
    TEMPLATE_BEG_SECTION(FUNCTION_PARAM_SECTION_SEPARATOR)\
      ", " \
    TEMPLATE_END_SECTION(FUNCTION_PARAM_SECTION_SEPARATOR) \
  TEMPLATE_END_SECTION(FUNCTION_PARAM_SECTION)

#define FUNCTION_EXPECT_AND_RETURN_NAME \
TEMPLATE_VAR(FUNCTION_STACK_VARIABLE_NAME) "_ExpectAndReturn("

#define FUNCTION_EXPECT_RETURN_AND_OUTPUT_PARAM \
FUNCTION_PARAM_LIST(FUNCTION_PARAM_SECTION, "") IF_RETURN_VALUE(IF_SECTION_EXISTS(FUNCTION_PARAM_LIST_SECTION, ", ") FUNCTION_TO_RETURN_VALUE_TYPE " to_return" TEMPLATE_INCL_SECTION(EXTRA_DECL_SECTION)) IF_SECTION_EXISTS(FUNCTION_PARAM_LIST_SECTION, ", ") FUNCTION_MATCHER_LIST

#define FUNCTION_EXPECT_AND_RETURN_SIGNATURE \
"void " FUNCTION_EXPECT_AND_RETURN_NAME FUNCTION_EXPECT_RETURN_AND_OUTPUT_PARAM ")"

#define FUNCTION_EXPECT_RETURN_AND_OUTPUT_NAME \
TEMPLATE_VAR(FUNCTION_STACK_VARIABLE_NAME) "_ExpectReturnAndOutput"

#define FUNCTION_EXPECT_RETURN_AND_OUTPUT_COMMON_NAME \
TEMPLATE_VAR(FUNCTION_STACK_VARIABLE_NAME) "_ExpectReturnAndOutput_common"

#define FUNCTION_EXPECT_RETURN_AND_OUTPUT_SIGNATURE_PARAM \
FUNCTION_EXPECT_RETURN_AND_OUTPUT_PARAM IF_SECTION_EXISTS(FUNCTION_PARAM_PTR_LIST_SECTION, ", ") FUNCTION_PARAM_LIST(FUNCTION_PARAM_PTR_SECTION, MOCK_OUT_PREFIX)

#define FUNCTION_EXPECT_RETURN_AND_OUTPUT_SIGNATURE \
"void " FUNCTION_EXPECT_RETURN_AND_OUTPUT_NAME "(" FUNCTION_EXPECT_RETURN_AND_OUTPUT_SIGNATURE_PARAM ")"

#define FUNCTION_EXPECT_RETURN_AND_OUTPUT_COMMON_SIGNATURE \
"void " FUNCTION_EXPECT_RETURN_AND_OUTPUT_COMMON_NAME "(" FUNCTION_EXPECT_RETURN_AND_OUTPUT_SIGNATURE_PARAM ")"

#define FUNCTION_EXPECT_RETURN_COMMON_CALL_PARAM \
FUNCTION_PARAM_CALL(FUNCTION_PARAM_SECTION, "") IF_RETURN_VALUE(IF_SECTION_EXISTS(FUNCTION_PARAM_LIST_SECTION, ", ") "to_return") IF_SECTION_EXISTS(FUNCTION_PARAM_LIST_SECTION, ", ") FUNCTION_MATCHER_CALL

#define INIT_ALL_MOCK_FUNCTION_NAME \
MOCK_FRAMEWORK_NAME "_initAllMocksInThisHeader"

#define RESET_ALL_MOCK_FUNCTION_NAME \
MOCK_FRAMEWORK_NAME "_resetAllMocksInThisHeader"

#define FUNCTION_INIT_ALL_MOCK_SIGNATURE \
"static void " INIT_ALL_MOCK_FUNCTION_NAME "()"

#define FUNCTION_RESET_ALL_MOCK_SIGNATURE \
"static void " RESET_ALL_MOCK_FUNCTION_NAME "()"

#define VERIFY_ALL_MOCK_FUNCTION_NAME \
MOCK_FRAMEWORK_NAME "_verifyAllMocksInThisHeader"

#define FUNCTION_VERIFY_ALL_MOCK_SIGNATURE \
"static easyMock_bool " VERIFY_ALL_MOCK_FUNCTION_NAME "()"

#define FUNCTION_MOCK_DATA_TYPE \
TEMPLATE_VAR(FUNCTION_STACK_VARIABLE_NAME) "_data"

#define FUNCTION_MOCK_DATA_RETURN_VALUE_VARIABLE \
TEMPLATE_VAR(FUNCTION_STACK_VARIABLE_NAME) "_returnValue"

#define FUNCTION_MOCK_DATA_CUR_MATCH_VAR \
TEMPLATE_VAR(FUNCTION_STACK_VARIABLE_NAME) "_match_" PARAMETER_NAME("")

#define CURRENT_DATA_CALL "currentDataCall"
#define CURRENT_DATA_CALL_MEMBER(member) CURRENT_DATA_CALL "." member
#define CURRENT_DATA_CALL_PTR(member) "*" CURRENT_DATA_CALL "." member

#define MOCKED_DATA "mockedData"
#define MOCKED_DATA_MEMBER(member) MOCKED_DATA "." member

#define FUNCTION_PARAMETERS "("  FUNCTION_PARAM_LIST(FUNCTION_PARAM_SECTION, "") IF_SECTION_EXISTS(VARIADIC_SECTION, VARIADIC_TEMPLATE_VAR) ")"
#define TEMPLATE_FUNCTION_TO_BE_MOCKED FUNCTION_ATTRIBUTE_DECLARATION_LIST FUNCTION_RETURN_VALUE_TYPE " " TEMPLATE_VAR(FUNCTION_STACK_VARIABLE_NAME) FUNCTION_PARAMETERS TEMPLATE_INCL_SECTION(EXTRA_TOP_LEVEL_DECL_SECTION)
#define MOCKED_FUN_CLASS(F_NAME) "mocked_" F_NAME
#define TEMPLATE_MOCKED_FUN_CLASS MOCKED_FUN_CLASS(TEMPLATE_VAR(FUNCTION_STACK_VARIABLE_NAME))

#define COMPOSED_TYPED_COMPARE_SECTION_DECL_NAME_VAR TEMPLATE_VAR(COMPOSED_TYPED_DECL_STRING)
#define COMPOSED_TYPED_COMPARE_SECTION_UNIQUE_NAME_VAR TEMPLATE_VAR(COMPOSED_TYPED_UNIQUE_NAME)
#define STRUCT_COMPARE_PARAM_SECTION_COMPARE_CONDITION_VAR TEMPLATE_VAR(COMPARE_CONDITION)
#define STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_FIELD_VAR TEMPLATE_VAR(STRUCT_COMPARE_FIELD)
#define STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_PRINTF_FORMAT_VAR TEMPLATE_VAR(STRUCT_COMPARE_PRINTF_FORMAT)
#define STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_STRUCT_TYPE_VAR TEMPLATE_VAR(STRUCT_COMPARE_TYPE)

#define COMPOSED_TYPED_COMPARE_FUNCTION_SIGNATURE \
"int cmp_" COMPOSED_TYPED_COMPARE_SECTION_UNIQUE_NAME_VAR "(const void *currentCall_ptr, const void *expectedCall_ptr, const char *paramName, char *errorMessage )"

#define GENERATE_COMMENT \
"/*------------------- GENERATING '" TEMPLATE_FUNCTION_TO_BE_MOCKED "' -------------------*/" CARRIAGE_RETURN \
"// from: " ORIGIN_FILE_TEMPLATE_VAR CARRIAGE_RETURN

#define END_GENERATE_COMMENT \
"/*----------------- END GENERATION '" TEMPLATE_FUNCTION_TO_BE_MOCKED "' -----------------*/"

namespace
{
/*!
 * \brief Template used to generate the implementation of the mock.
 */
const char templateText[] =
        "// THIS FILE IS AUTOGENERATED BY EASYMOCKGENERATE! PLEASE DO NOT EDIT" CARRIAGE_RETURN
        "#include <easyMock_framework.h>" CARRIAGE_RETURN
        "#include <easyMock_glueStdlib.h>" CARRIAGE_RETURN
        "#include <MockedFunction.h>" CARRIAGE_RETURN
        "#include <cstring.h>" CARRIAGE_RETURN
        CARRIAGE_RETURN
        "#include \"" MOCK_FRAMEWORK_NAME "_" TEMPLATE_VAR(MOCKED_HEADER_FILENAME) "\"" CARRIAGE_RETURN
        CARRIAGE_RETURN

        FUNCTION_INIT_ALL_MOCK_SIGNATURE ";" CARRIAGE_RETURN
        FUNCTION_RESET_ALL_MOCK_SIGNATURE ";" CARRIAGE_RETURN
        FUNCTION_VERIFY_ALL_MOCK_SIGNATURE ";" CARRIAGE_RETURN
        CARRIAGE_RETURN

        TEMPLATE_BEG_SECTION(COMPOSED_TYPE_COMPARE_SECTION)
        COMPOSED_TYPED_COMPARE_FUNCTION_SIGNATURE CARRIAGE_RETURN
        "{" CARRIAGE_RETURN

        "    // Start COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_SECTION" CARRIAGE_RETURN
        "    " TEMPLATE_INCL_SECTION(COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_SECTION) CARRIAGE_RETURN
        "    // End COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_SECTION" CARRIAGE_RETURN

        "    " IF_SECTION_EXISTS(NON_TYPED_DEF_COMPOSED_TYPE_SECTION, COMPOSED_TYPE_TEMPLATE_VAR " ") COMPOSED_TYPED_COMPARE_SECTION_DECL_NAME_VAR " *currentCall_val = (" IF_SECTION_EXISTS(NON_TYPED_DEF_COMPOSED_TYPE_SECTION, COMPOSED_TYPE_TEMPLATE_VAR " ") COMPOSED_TYPED_COMPARE_SECTION_DECL_NAME_VAR " *)currentCall_ptr;" CARRIAGE_RETURN
        "    " IF_SECTION_EXISTS(NON_TYPED_DEF_COMPOSED_TYPE_SECTION, COMPOSED_TYPE_TEMPLATE_VAR " ") COMPOSED_TYPED_COMPARE_SECTION_DECL_NAME_VAR " *expectedCall_val = (" IF_SECTION_EXISTS(NON_TYPED_DEF_COMPOSED_TYPE_SECTION, COMPOSED_TYPE_TEMPLATE_VAR " ") COMPOSED_TYPED_COMPARE_SECTION_DECL_NAME_VAR " *)expectedCall_ptr;" CARRIAGE_RETURN

        TEMPLATE_BEG_SECTION(STRUCT_COMPARE_PARAM_SECTION)
        TEMPLATE_BEG_SECTION(STRUCT_COMPARE_PRE_IF_SECTION)
        "    CSTRING_AUTOCLEAN(" TEMPLATE_VAR(STRUCT_COMPARE_PRE_IF_SECTION_VAR_NAME) ") = cstring_new_init(paramName);" CARRIAGE_RETURN
        "    cstring_append(&" TEMPLATE_VAR(STRUCT_COMPARE_PRE_IF_SECTION_VAR_NAME) ", \"" TEMPLATE_VAR(STRUCT_COMPARE_PRE_IF_SECTION_FIELD_NAME) "\");" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(STRUCT_COMPARE_PRE_IF_SECTION)
        "    if(" STRUCT_COMPARE_PARAM_SECTION_COMPARE_CONDITION_VAR ")" CARRIAGE_RETURN
        "    {" CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(STRUCT_COMPARE_ERROR)
        "        easyMock_snprintf(errorMessage, 256 , \"Parameter '%s' which is a" COMPOSED_TYPE_TEMPLATE_VAR " of type '" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_STRUCT_TYPE_VAR "' has field '" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_FIELD_VAR "' with value '%" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_PRINTF_FORMAT_VAR "', was expecting '%" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_PRINTF_FORMAT_VAR "'\", paramName, currentCall_val->" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_FIELD_VAR ", expectedCall_val->" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_FIELD_VAR ");" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(STRUCT_COMPARE_ERROR)
        "        return -1;" CARRIAGE_RETURN
        "    }" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(STRUCT_COMPARE_PARAM_SECTION)

        TEMPLATE_BEG_SECTION(STRUCT_COMPARE_ARRAY_SECTION)
        "    for(unsigned int idx = 0; idx < (sizeof(currentCall_val->" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_FIELD_VAR ")/sizeof(currentCall_val->" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_FIELD_VAR "[0])); idx++)" CARRIAGE_RETURN
        "    {" CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(STRUCT_COMPARE_PRE_IF_SECTION)
        "        CSTRING_AUTOCLEAN(" TEMPLATE_VAR(STRUCT_COMPARE_PRE_IF_SECTION_VAR_NAME) ") = cstring_new_init(paramName);" CARRIAGE_RETURN
        "        cstring_append(&" TEMPLATE_VAR(STRUCT_COMPARE_PRE_IF_SECTION_VAR_NAME) ", \"" TEMPLATE_VAR(STRUCT_COMPARE_PRE_IF_SECTION_FIELD_NAME) "\");" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(STRUCT_COMPARE_PRE_IF_SECTION)
        "        if(" STRUCT_COMPARE_PARAM_SECTION_COMPARE_CONDITION_VAR ")" CARRIAGE_RETURN
        "        {" CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(STRUCT_COMPARE_ERROR)
        "            easyMock_snprintf(errorMessage, 256 , \"Parameter '%s' which is a" COMPOSED_TYPE_TEMPLATE_VAR " of type '" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_STRUCT_TYPE_VAR "' has field array '" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_FIELD_VAR "' " PRINT_CMP_ARRAY_IDX " with value '%" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_PRINTF_FORMAT_VAR "', was expecting '%" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_PRINTF_FORMAT_VAR "'\", paramName" PRINT_CMP_ARRAY_IDX_value ",  currentCall_val->" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_FIELD_VAR ", expectedCall_val->" STRUCT_COMPARE_ERROR_SECTION_STRUCT_COMPARE_FIELD_VAR ");" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(STRUCT_COMPARE_ERROR)
        "            return -1;" CARRIAGE_RETURN
        "        }" CARRIAGE_RETURN
        "    }" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(STRUCT_COMPARE_ARRAY_SECTION)

        "    return 0;" CARRIAGE_RETURN
        "}" CARRIAGE_RETURN
        CARRIAGE_RETURN
        TEMPLATE_END_SECTION(COMPOSED_TYPE_COMPARE_SECTION)

        TEMPLATE_BEG_SECTION(FUNCTION_SECTION)
        GENERATE_COMMENT CARRIAGE_RETURN
        "typedef struct {" CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(FUNCTION_PARAM_SECTION)
        "    " DECLARE_NON_QUALIFIED_PARAMETER("") ";" CARRIAGE_RETURN
        "    EasyMock_Matcher " FUNCTION_MOCK_DATA_CUR_MATCH_VAR ";" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_PARAM_SECTION)
        IF_RETURN_VALUE("    " FUNCTION_NON_QUALIFIED_RETURN_VALUE_TYPE " " FUNCTION_MOCK_DATA_RETURN_VALUE_VARIABLE TEMPLATE_INCL_SECTION(EXTRA_DECL_SECTION) ";" CARRIAGE_RETURN)
        TEMPLATE_BEG_SECTION(FUNCTION_PARAM_PTR_SECTION)
        "    " DECLARE_PARAMETER(MOCK_OUT_PREFIX) ";" CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(FUNCTION_VOID_PTR_OUT_SECTION)
        "    easyMock_size_t " PARAMETER_OUT_SIZE_VAR ";" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_VOID_PTR_OUT_SECTION)
        TEMPLATE_END_SECTION(FUNCTION_PARAM_PTR_SECTION)
        "} " FUNCTION_MOCK_DATA_TYPE";" CARRIAGE_RETURN
        CARRIAGE_RETURN
        "static " FUNCTION_EXPECT_RETURN_AND_OUTPUT_COMMON_SIGNATURE ";" CARRIAGE_RETURN
        "static MockedFunction " TEMPLATE_MOCKED_FUN_CLASS ";" CARRIAGE_RETURN
        IF_RETURN_VALUE("static " FUNCTION_NON_QUALIFIED_RETURN_VALUE_TYPE " dummyRes_" TEMPLATE_VAR(FUNCTION_STACK_VARIABLE_NAME) TEMPLATE_INCL_SECTION(EXTRA_DECL_SECTION) ";" CARRIAGE_RETURN)
        CARRIAGE_RETURN
        TEMPLATE_FUNCTION_TO_BE_MOCKED CARRIAGE_RETURN
        "{" CARRIAGE_RETURN
        "    easyMock_bool printCallStack = easyMock_printCallStack();" CARRIAGE_RETURN
        "    easyMock_bool checkCallsOrder = easyMock_checkCallsOrder();" CARRIAGE_RETURN
        CARRIAGE_RETURN
        IF_RETURN_VALUE
        (
            "    " FUNCTION_NON_QUALIFIED_RETURN_VALUE_TYPE " default_res" TEMPLATE_INCL_SECTION(EXTRA_TOP_LEVEL_DECL_SECTION) ";" CARRIAGE_RETURN
            "    easyMock_memcpy((void*)&default_res, (void*)&dummyRes_" TEMPLATE_VAR(FUNCTION_STACK_VARIABLE_NAME) ", sizeof(default_res));" CARRIAGE_RETURN
            CARRIAGE_RETURN
        )
        "    if(!MockedFunction_addActualCall(&" TEMPLATE_MOCKED_FUN_CLASS "))" CARRIAGE_RETURN
        "    {" CARRIAGE_RETURN
        "        easyMock_addError(printCallStack, \"Error : unexpected call of '%s'." IF_RETURN_VALUE(" " TEMPLATE_VAR(FUNCTION_STACK_VARIABLE_NAME) " is returning a random value.") "\", MockedFunction_getName(&" TEMPLATE_MOCKED_FUN_CLASS "));" CARRIAGE_RETURN
        "        return" IF_RETURN_VALUE(" default_res") ";" CARRIAGE_RETURN
        "    }" CARRIAGE_RETURN
        CARRIAGE_RETURN
        "    " FUNCTION_MOCK_DATA_TYPE " " CURRENT_DATA_CALL ";" CARRIAGE_RETURN
        "    if (!MockedFunction_getCurrentCallParam(&" TEMPLATE_MOCKED_FUN_CLASS ", &" CURRENT_DATA_CALL "))" CARRIAGE_RETURN
        "    {" CARRIAGE_RETURN
        "        easyMock_addError(printCallStack, \"BUG IN EASYMOCK: CONTACT DEVELOPPER TO FIX THIS\");" CARRIAGE_RETURN
        "        return" IF_RETURN_VALUE(" default_res") ";" CARRIAGE_RETURN
        "    }" CARRIAGE_RETURN
        CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(FUNCTION_PARAM_SECTION)
        "    if(" CURRENT_DATA_CALL_MEMBER(FUNCTION_MOCK_DATA_CUR_MATCH_VAR) " != easyMock_null)" CARRIAGE_RETURN
        "    {" CARRIAGE_RETURN
        "        char errorMessage[EASYMOCK_MAX_CMP_ERR] = {0};" CARRIAGE_RETURN
        "        void *curCallVal = (void *) &" PARAMETER_NAME("") ";" CARRIAGE_RETURN
        "        void *expectedCallVal = (void *) &" CURRENT_DATA_CALL_MEMBER(PARAMETER_NAME("")) ";" CARRIAGE_RETURN
        "        EasyMock_Matcher matcher = " CURRENT_DATA_CALL_MEMBER(FUNCTION_MOCK_DATA_CUR_MATCH_VAR) ";" CARRIAGE_RETURN
        "        int error = matcher(curCallVal, expectedCallVal, \"" PARAMETER_NAME("") "\", errorMessage);" CARRIAGE_RETURN
        "        if(error)" CARRIAGE_RETURN
        "        {" CARRIAGE_RETURN
        "            easyMock_addError(printCallStack, \"Error : at call %d of '%s': %s\", MockedFunction_getNbActualCall(&" TEMPLATE_MOCKED_FUN_CLASS "), MockedFunction_getName(&" TEMPLATE_MOCKED_FUN_CLASS "), errorMessage);" CARRIAGE_RETURN
        "        }" CARRIAGE_RETURN
        "    }" CARRIAGE_RETURN
        CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_PARAM_SECTION)
        IF_RETURN_VALUE("    default_res = currentDataCall." FUNCTION_MOCK_DATA_RETURN_VALUE_VARIABLE ";" CARRIAGE_RETURN)
        CARRIAGE_RETURN
        "    CSTRING_AUTOCLEAN(currentCall) = easyMock_popCurrentCall();" CARRIAGE_RETURN
        "    if(checkCallsOrder)" CARRIAGE_RETURN
        "    {" CARRIAGE_RETURN
        "        const char* curFuncCall = MockedFunction_getName(&" TEMPLATE_MOCKED_FUN_CLASS ");" CARRIAGE_RETURN
        "        if(cstring_compare_const_char(&currentCall, curFuncCall) != 0)" CARRIAGE_RETURN
        "        {" CARRIAGE_RETURN
        "            easyMock_addError(printCallStack, \"Error : got call to '%s',  but was expecting call to '%s'\", MockedFunction_getName(&" TEMPLATE_MOCKED_FUN_CLASS "), cstring_c_str(&currentCall));" CARRIAGE_RETURN
        "            return" IF_RETURN_VALUE(" default_res") ";" CARRIAGE_RETURN
        "        }" CARRIAGE_RETURN
        "    }" CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(FUNCTION_PARAM_PTR_SECTION)
        "    if(" CURRENT_DATA_CALL_MEMBER(PARAMETER_NAME(MOCK_OUT_PREFIX)) ")" CARRIAGE_RETURN
        "    {" CARRIAGE_RETURN
        "        easyMock_memcpy((void*)" PARAMETER_NAME("") ", (void*)" CURRENT_DATA_CALL_MEMBER(PARAMETER_NAME(MOCK_OUT_PREFIX)) ", " IF_SECTION_EXISTS(FUNCTION_VOID_PTR_OUT_SECTION, CURRENT_DATA_CALL_MEMBER(PARAMETER_OUT_SIZE_VAR)) IF_SECTION_EXISTS(FUNCTION_NON_VOID_PTR_OUT_SECTION, "sizeof(*" PARAMETER_NAME("") ")" ) ");" CARRIAGE_RETURN
        "    }" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_PARAM_PTR_SECTION)
        IF_RETURN_VALUE(CARRIAGE_RETURN "    return default_res;" CARRIAGE_RETURN)
        "}" CARRIAGE_RETURN
        CARRIAGE_RETURN
        FUNCTION_EXPECT_AND_RETURN_SIGNATURE CARRIAGE_RETURN
        "{" CARRIAGE_RETURN
        "    " FUNCTION_EXPECT_RETURN_AND_OUTPUT_COMMON_NAME "(" FUNCTION_EXPECT_RETURN_COMMON_CALL_PARAM IF_SECTION_EXISTS(FUNCTION_PARAM_PTR_LIST_SECTION, ", ") FUNCTION_HARDCODED_PARAM_CALL(FUNCTION_PARAM_PTR_SECTION, "easyMock_null") ");" CARRIAGE_RETURN
        "}" CARRIAGE_RETURN
        CARRIAGE_RETURN
        IF_SECTION_EXISTS(FUNCTION_PARAM_PTR_LIST_SECTION,
             FUNCTION_EXPECT_RETURN_AND_OUTPUT_SIGNATURE CARRIAGE_RETURN
             "{" CARRIAGE_RETURN
             "    " FUNCTION_EXPECT_RETURN_AND_OUTPUT_COMMON_NAME "(" FUNCTION_EXPECT_RETURN_COMMON_CALL_PARAM IF_SECTION_EXISTS(FUNCTION_PARAM_PTR_LIST_SECTION, ", ") FUNCTION_PARAM_CALL(FUNCTION_PARAM_PTR_SECTION, MOCK_OUT_PREFIX) ");" CARRIAGE_RETURN
             "}" CARRIAGE_RETURN
        ) CARRIAGE_RETURN
        "static " FUNCTION_EXPECT_RETURN_AND_OUTPUT_COMMON_SIGNATURE CARRIAGE_RETURN
        "{" CARRIAGE_RETURN
        "    " FUNCTION_MOCK_DATA_TYPE " " MOCKED_DATA ";" CARRIAGE_RETURN
        CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(FUNCTION_PARAM_SECTION)
        "    easyMock_memcpy((void*)&" MOCKED_DATA_MEMBER(PARAMETER_NAME("")) ", (void*)&" PARAMETER_NAME("") ", sizeof(" MOCKED_DATA_MEMBER(PARAMETER_NAME("")) "));" CARRIAGE_RETURN
        "    " MOCKED_DATA_MEMBER(FUNCTION_MOCK_DATA_CUR_MATCH_VAR) " = " FUNCTION_PARAM_MATCH_VAR ";" CARRIAGE_RETURN
        CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_PARAM_SECTION)

        TEMPLATE_BEG_SECTION(FUNCTION_PARAM_PTR_SECTION)

        TEMPLATE_BEG_SECTION(FUNCTION_VOID_PTR_OUT_SECTION)
        "    " MOCKED_DATA_MEMBER(PARAMETER_OUT_SIZE_VAR) " = " PARAMETER_OUT_SIZE_VAR ";" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_VOID_PTR_OUT_SECTION)

        "    easyMock_memcpy((void*)&" MOCKED_DATA_MEMBER(PARAMETER_NAME(MOCK_OUT_PREFIX)) ", (void*)&" PARAMETER_NAME(MOCK_OUT_PREFIX) ", sizeof(" MOCKED_DATA_MEMBER(PARAMETER_NAME(MOCK_OUT_PREFIX)) "));" CARRIAGE_RETURN

        CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_PARAM_PTR_SECTION)

        IF_RETURN_VALUE("    " MOCKED_DATA_MEMBER(FUNCTION_MOCK_DATA_RETURN_VALUE_VARIABLE) " = to_return;" CARRIAGE_RETURN CARRIAGE_RETURN)
        "    MockedFunction_addExpectedCall(&" TEMPLATE_MOCKED_FUN_CLASS ", &mockedData);" CARRIAGE_RETURN
        "    easyMock_addCall(MockedFunction_getName(&" TEMPLATE_MOCKED_FUN_CLASS "));" CARRIAGE_RETURN
        "}" CARRIAGE_RETURN
        CARRIAGE_RETURN
        END_GENERATE_COMMENT CARRIAGE_RETURN
        CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_SECTION)
        CARRIAGE_RETURN
        FUNCTION_RESET_ALL_MOCK_SIGNATURE CARRIAGE_RETURN
        "{" CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(FUNCTION_SECTION)
        "    MockedFunction_reset(&" TEMPLATE_MOCKED_FUN_CLASS ");" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_SECTION)
        "}" CARRIAGE_RETURN
        FUNCTION_INIT_ALL_MOCK_SIGNATURE CARRIAGE_RETURN
        "{" CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(FUNCTION_SECTION)
        "    MockedFunction_init(&" TEMPLATE_MOCKED_FUN_CLASS ", \"" TEMPLATE_FUNCTION_TO_BE_MOCKED "\", sizeof(" FUNCTION_MOCK_DATA_TYPE ") );" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_SECTION)
        "}"
        CARRIAGE_RETURN
        FUNCTION_VERIFY_ALL_MOCK_SIGNATURE CARRIAGE_RETURN
        "{" CARRIAGE_RETURN
        "    easyMock_bool rv = easyMock_true;" CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(FUNCTION_SECTION)
        "    if(!MockedFunction_verify(&" TEMPLATE_MOCKED_FUN_CLASS "))" CARRIAGE_RETURN
        "    {" CARRIAGE_RETURN
        "        rv = easyMock_false;" CARRIAGE_RETURN
        "    }" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_SECTION)
        "    return rv;" CARRIAGE_RETURN
        "}" CARRIAGE_RETURN
        CARRIAGE_RETURN
        "static " MOCK_FRAMEWORK_NAME "_mockedFileRegister_t mockedRegister = {\"" TEMPLATE_VAR(MOCKED_HEADER_FILENAME) "\", &" RESET_ALL_MOCK_FUNCTION_NAME ", &" VERIFY_ALL_MOCK_FUNCTION_NAME " };" CARRIAGE_RETURN
        CARRIAGE_RETURN
        "static void __attribute__((constructor(102))) " MOCK_FRAMEWORK_NAME "_register_this_header()" CARRIAGE_RETURN
        "{" CARRIAGE_RETURN
        "    " INIT_ALL_MOCK_FUNCTION_NAME "();" CARRIAGE_RETURN
        "    " MOCK_FRAMEWORK_NAME "_registerMockedFile(&mockedRegister);" CARRIAGE_RETURN
        "}" CARRIAGE_RETURN
        CARRIAGE_RETURN
        "static void __attribute__((destructor)) " MOCK_FRAMEWORK_NAME "_unregister_this_header()" CARRIAGE_RETURN
        "{" CARRIAGE_RETURN
        "    " RESET_ALL_MOCK_FUNCTION_NAME "();" CARRIAGE_RETURN
        "    " MOCK_FRAMEWORK_NAME "_unregisterMockedFile(&mockedRegister);" CARRIAGE_RETURN
        "}" CARRIAGE_RETURN;

/*!
 * \brief Template used to generate the header file of the mock.
 */
const char headerFileTemplate[] =
        "// THIS FILE IS AUTOGENERATED BY EASYMOCKGENERATE! PLEASE DO NOT EDIT" CARRIAGE_RETURN
        "#ifndef _" TEMPLATE_VAR(MOCKED_FILE_NAME_WITHOUT_EXT_UPPER) "_" MOCK_FRAMEWORK_NAME_UPPER "_H" CARRIAGE_RETURN
        "#define _" TEMPLATE_VAR(MOCKED_FILE_NAME_WITHOUT_EXT_UPPER) "_" MOCK_FRAMEWORK_NAME_UPPER "_H" CARRIAGE_RETURN
        CARRIAGE_RETURN
        IF_SECTION_EXISTS(INCLUDE_MOCKED_HEADER_SECTION,
          "#include \"" TEMPLATE_VAR(MOCKED_HEADER_FILENAME) "\"" CARRIAGE_RETURN
        )
        "#include <stdarg.h>" CARRIAGE_RETURN
        "#include <" MOCK_FRAMEWORK_NAME ".h>" CARRIAGE_RETURN
        CARRIAGE_RETURN
        "#ifdef __cplusplus" CARRIAGE_RETURN
        "extern \"C\" {" CARRIAGE_RETURN
        "#endif" CARRIAGE_RETURN
        IF_SECTION_EXISTS(GENERATE_USED_TYPE_SECTION,
          /*
           * For the generated used type, we guard the definition with #ifdef
           * because when a user mocks several header using the same types
           * and includes them all together we must make sure we pick only one
           * definition.
           */
          "/*------------------ GENERATING USED TYPE -------------------*/"  CARRIAGE_RETURN

          TEMPLATE_BEG_SECTION(GENERATED_MACRO_SECTION)
          "#ifndef " GENERATED_MACRO_ID_TEMPLATE_VAR CARRIAGE_RETURN
          "// from: " ORIGIN_FILE_TEMPLATE_VAR CARRIAGE_RETURN
          "#define " GENERATED_MACRO_ID_TEMPLATE_VAR
          IF_SECTION_EXISTS(GENERATED_MACRO_PARAMETERS_SECTION, GENERATED_MACRO_PARAMETERS_TEMPLATE_VAR " ")
          IF_SECTION_EXISTS(GENERATED_MACRO_DEFINITION_SECTION, " " GENERATED_MACRO_DEFINITION_TEMPLATE_VAR) CARRIAGE_RETURN
          "#endif //macro " GENERATED_MACRO_ID_TEMPLATE_VAR CARRIAGE_RETURN
          CARRIAGE_RETURN
          TEMPLATE_END_SECTION(GENERATED_MACRO_SECTION)

          TEMPLATE_BEG_SECTION(GENERATED_TYPE_FORWARD_DECLARATION_SECTION)
          "#ifndef " GENERATED_TYPE_FORWARD_DECLARATION_GUARD_NAME CARRIAGE_RETURN
          "#define " GENERATED_TYPE_FORWARD_DECLARATION_GUARD_NAME CARRIAGE_RETURN
          TEMPLATE_INCL_SECTION(COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_SECTION) " //GENERATED_TYPE_FORWARD_DECLARATION_SECTION" CARRIAGE_RETURN
          "#endif //" GENERATED_TYPE_FORWARD_DECLARATION_GUARD_NAME CARRIAGE_RETURN
          TEMPLATE_END_SECTION(GENERATED_TYPE_FORWARD_DECLARATION_SECTION)

          TEMPLATE_BEG_SECTION(GENERATED_TYPE_SIMPLE_TYPEDEF_SECTION)
          "#ifndef " GENERATED_TYPE_SIMPLE_TYPEDEF_GUARD_NAME CARRIAGE_RETURN
          "#define " GENERATED_TYPE_SIMPLE_TYPEDEF_GUARD_NAME CARRIAGE_RETURN
          "typedef " GENERATED_TYPE_SIMPLE_TYPEDEF_TYPEE_TEMPLATE_VAR " " GENERATED_TYPE_SIMPLE_TYPEDEF_TYPED_TEMPLATE_VAR ";" CARRIAGE_RETURN
          "#endif //" GENERATED_TYPE_SIMPLE_TYPEDEF_GUARD_NAME CARRIAGE_RETURN
          TEMPLATE_END_SECTION(GENERATED_TYPE_SIMPLE_TYPEDEF_SECTION)

          TEMPLATE_BEG_SECTION(GENERATED_TYPE_ENUM_SECTION)
          "#ifndef " GENERATED_TYPE_ENUM_GUARD_NAME CARRIAGE_RETURN
          "#define " GENERATED_TYPE_ENUM_GUARD_NAME CARRIAGE_RETURN
          "enum " GENERATED_TYPE_ENUM_NAME_TEMPLATE_VAR CARRIAGE_RETURN
          "{" CARRIAGE_RETURN
          TEMPLATE_BEG_SECTION(GENERATED_TYPE_ENUM_VALUE_SECTION)
          "  " GENERATED_TYPE_ENUM_VALUE_NAME_TEMPLATE_VAR " = " GENERATED_TYPE_ENUM_VALUE_VALUE_TEMPLATE_VAR "," CARRIAGE_RETURN
          TEMPLATE_END_SECTION(GENERATED_TYPE_ENUM_VALUE_SECTION)
          "};" CARRIAGE_RETURN
          "#endif //" GENERATED_TYPE_ENUM_GUARD_NAME CARRIAGE_RETURN
          TEMPLATE_END_SECTION(GENERATED_TYPE_ENUM_SECTION)

          TEMPLATE_BEG_SECTION(GENERATED_TYPE_SECTION)
          "#ifndef " GENERATED_TYPE_DECLARE_MACRO_GUARD_NAME CARRIAGE_RETURN
          "#define " GENERATED_TYPE_DECLARE_MACRO_GUARD_NAME CARRIAGE_RETURN
          "//GENERATED_TYPE_SECTION" CARRIAGE_RETURN
          IF_SECTION_EXISTS(GENERATED_TYPE_DECLARE_TYPE_SECTION,
            GENERATED_TYPE_DECLARE_TYPE_TEMPLATE_VAR ";"
          )
          TEMPLATE_INCL_SECTION(COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_SECTION)
          CARRIAGE_RETURN
          "#endif //" GENERATED_TYPE_DECLARE_MACRO_GUARD_NAME CARRIAGE_RETURN
          TEMPLATE_END_SECTION(GENERATED_TYPE_SECTION)

          "/*----------------- END GENERATING USED TYPE -----------------*/"  CARRIAGE_RETURN
        ) //IF_SECTION_EXISTS(GENERATE_USED_TYPE_SECTION,
        CARRIAGE_RETURN
        TEMPLATE_BEG_SECTION(COMPOSED_TYPE_COMPARE_SECTION)
        COMPOSED_TYPED_COMPARE_FUNCTION_SIGNATURE ";" CARRIAGE_RETURN
        TEMPLATE_END_SECTION(COMPOSED_TYPE_COMPARE_SECTION)
        TEMPLATE_BEG_SECTION(FUNCTION_SECTION)
        "/*------------------- GENERATING '" TEMPLATE_FUNCTION_TO_BE_MOCKED "' -------------------*/" CARRIAGE_RETURN
        "// from: " ORIGIN_FILE_TEMPLATE_VAR CARRIAGE_RETURN
        IF_SECTION_EXISTS(GENERATE_MOCKED_TYPE_SECTION,
          TEMPLATE_FUNCTION_TO_BE_MOCKED ";" CARRIAGE_RETURN
        )
        FUNCTION_EXPECT_AND_RETURN_SIGNATURE ";" CARRIAGE_RETURN
        IF_SECTION_EXISTS(FUNCTION_PARAM_PTR_LIST_SECTION, FUNCTION_EXPECT_RETURN_AND_OUTPUT_SIGNATURE ";" CARRIAGE_RETURN)
        "/*----------------- END GENERATION '" TEMPLATE_FUNCTION_TO_BE_MOCKED "' -----------------*/" CARRIAGE_RETURN
        CARRIAGE_RETURN
        TEMPLATE_END_SECTION(FUNCTION_SECTION)
        "#ifdef __cplusplus" CARRIAGE_RETURN
        "}" CARRIAGE_RETURN
        "#endif" CARRIAGE_RETURN
        "#endif" CARRIAGE_RETURN;

const char composableType_DeclareComposableType_template[] =
        COMPOSABLE_TYPE_DECLARATION_TYPE_TEMPLATE_VAR " " COMPOSABLE_TYPE_TYPE_NAME_TEMPLATE_VAR
        IF_SECTION_EXISTS(COMPOSABLE_TYPE_BODY_SECTION,
        CARRIAGE_RETURN
        "{" CARRIAGE_RETURN
        "    " TEMPLATE_INCL_SECTION(COMPOSABLE_TYPE_DECLARE_TYPE_FIELD_OR_COMPOSABLE_TYPE_FIELD_SECTION) CARRIAGE_RETURN
        "}"
        )
        IF_SECTION_EXISTS(COMPOSABLE_TYPE_INLINE_DECL_FIELD_NAME_SECTION, " " COMPOSABLE_TYPE_INLINE_DECL_FIELD_NAME_TEMPLATE_VAR)
        ";" CARRIAGE_RETURN;

const char composableType_DeclareTypeFieldOrComposableTypeField_template[] =
        IF_SECTION_EXISTS(COMPOSABLE_TYPE_DECLARE_TYPE_SECTION,
          TYPE_DECLARATION_TEMPLATE_VAR " " TYPE_NAME_TEMPLATE_VAR TEMPLATE_INCL_SECTION(EXTRA_DECL_SECTION) ";" CARRIAGE_RETURN
        )
        TEMPLATE_INCL_SECTION(COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_SECTION);

const char extraDeclTemplate[] =
        ")"
        FUNCTION_PARAMETERS
        TEMPLATE_BEG_SECTION(EXTRA_DECL_SECTION "INSIDE")
        TEMPLATE_INCL_SECTION(EXTRA_DECL_SECTION)
        TEMPLATE_END_SECTION(EXTRA_DECL_SECTION "INSIDE");

const char extraTopDeclTemplate[] =
        ")" FUNCTION_PARAMETERS
        TEMPLATE_BEG_SECTION(EXTRA_TOP_LEVEL_DECL_SECTION "INSIDE")
        TEMPLATE_INCL_SECTION(EXTRA_TOP_LEVEL_DECL_SECTION)
        TEMPLATE_END_SECTION(EXTRA_TOP_LEVEL_DECL_SECTION "INSIDE");

inline std::string getAnonymousName(const TypeItf* p_type)
{
  static const std::string GENERATED_ANONYMOUS_TYPE_PREFIX { "easymock_generated_anonymous_type_hash_" };
  return GENERATED_ANONYMOUS_TYPE_PREFIX + std::to_string(p_type->getHash());
}

const TypeItf* getUnqualifiedAndUntypedefType(const TypeItf* p_type)
{
  const QualifiedType* qualifiedType = p_type->asQualifiedType();
  if(qualifiedType)
  {
    return getUnqualifiedAndUntypedefType(qualifiedType->getUnqualifiedType());
  }

  const TypedefType* typedefType = p_type->asTypedefType();
  if(typedefType)
  {
    return getUnqualifiedAndUntypedefType(typedefType->getTypee());
  }

  return p_type;
}

const TypedefType* getTypeDefType(const TypeItf* p_type)
{
  const TypedefType* typeDefType = p_type->asTypedefType();
  if(typeDefType)
  {
    return typeDefType;
  }
  const Pointer* pointerType = p_type->asPointer();
  if(pointerType)
  {
    return getTypeDefType(pointerType->getPointedType());
  }
  const QualifiedType* qualifiedType = p_type->asQualifiedType();
  if(qualifiedType)
  {
    return getTypeDefType(qualifiedType->getUnqualifiedType());
  }
  return nullptr;
}

bool isComposableTypeComplete(const ComposableType* composableType)
{
  for(const auto field : composableType->getContainedFields())
  {
    if(field->getType()->unqualify()->isIncompleteType())
    {
      return false;
    }
  }
  return true;
}

bool doesFunctionUsesEmptyEnum(const FunctionDeclaration& fd)
{
  const Enum* rv = fd.getReturnType()->getType()->unqualify()->asEnum();
  if(rv && rv->getValues().empty())
  {
    return true;
  }
  for(const auto& param: fd.getFunctionsParameters())
  {
    const Enum* p = param->getType()->unqualify()->asEnum();
    if(p && p->getValues().empty())
    {
      return true;
    }
  }
  return false;
}

} //namespace

const TypeItf* CodeGeneratorCTemplate::getRawType(const TypeItf* p_type)
{
  const Pointer* pointerType = p_type->asPointer();
  if(pointerType)
  {
    return getRawType(pointerType->getPointedType());
  }

  const QualifiedType* qualifiedType = p_type->asQualifiedType();
  if(qualifiedType)
  {
    return getRawType(qualifiedType->getUnqualifiedType());
  }

  const TypedefType* typedefType = p_type->asTypedefType();
  if(typedefType)
  {
    /*
     * Instead of calling registerTypeDef at each place we discover a new type, we prefer to register the typedef
     * in the list whenever we encounter one via this function. This is working in most of the case because
     * we need to know the raw type at one moment in the mock generation. The only exception is for the return values
     * where we need to call registerTypeDef manually.
     */
    registerTypeDef(p_type);
    return getRawType(typedefType->getTypee());
  }

  return p_type;
}

void CodeGeneratorCTemplate::registerTypeDef(const TypeItf *p_type)
{
  const TypedefType* typeDefType = getTypeDefType(p_type);
  if(typeDefType)
  {
    const TypeItf* typeeType = typeDefType->getTypee();
    if(m_typeToTypedef.find(typeeType) == m_typeToTypedef.end())
      m_typeToTypedef.insert({typeeType, typeDefType});
  }
}

const std::string& CodeGeneratorCTemplate::getTypeDefName(const TypeItf *p_type)
{
  auto itr = m_typeToTypedef.find(p_type);
  if(itr != m_typeToTypedef.end())
  {
    return itr->second->getName();
  }
  static std::string notFound{ "" };
  return notFound;
}

const std::string& CodeGeneratorCTemplate::getMostDefinedName(const TypeItf* p_type)
{
  const std::string& typeDefName = getTypeDefName(p_type);
  if(!typeDefName.empty())
  {
    return typeDefName;
  }
  const std::string& typeName = p_type->getName();
  return typeName;
}

template <class T>
std::string CodeGeneratorCTemplate::getComparatorName(const T* p_composableType)
{
  std::string comparatorName { "" };

  const std::string& composableTypeDefName = getTypeDefName(p_composableType);
  if(composableTypeDefName.empty())
  {
    comparatorName += p_composableType->getComposableTypeKeyword();
    comparatorName.push_back('_');
  }

  if(composableTypeDefName.empty())
  {
    const std::string& composableTypeName = p_composableType->getName();
    if(!composableTypeName.empty())
    {
      comparatorName += composableTypeName;
    }
    else
    {
      comparatorName += getAnonymousTypedefUniqueName(p_composableType);
    }
  }
  else
  {
    comparatorName += composableTypeDefName;
  }
  return comparatorName;
}

std::string CodeGeneratorCTemplate::getAnonymousTypedefUniqueName(const TypeItf* p_type)
{
  std::string anonymousName { getTypeDefName(p_type) };
  if(anonymousName.empty())
  {
    anonymousName += getAnonymousName(p_type);
  }
  return anonymousName;
}

CodeGeneratorCTemplate::CodeGeneratorCTemplate():
CodeGeneratorItf{} , m_nbUnamedParam { 0 }
{
}

bool CodeGeneratorCTemplate::generateCodeImplementation(const std::string& p_outDir, const std::string &p_fullPathToHeaderToMock, const ElementToMockContext& p_ctxt)
{
  ctemplate::TemplateDictionary dict("generateCode");
  m_rootDictionary = &dict;
  m_generateMockedTypeSection = nullptr;
  if(m_generateUsedType)
  {
    m_generateMockedTypeSection = m_rootDictionary->AddSectionDictionary(GENERATE_USED_TYPE_SECTION);
  }
  else
  {
    m_rootDictionary->AddSectionDictionary(INCLUDE_MOCKED_HEADER_SECTION);
  }
  m_generatedTypeTypedDefSection.clear();
  m_generatedTypeEnumSection.clear();
  m_typeToTypedef.clear();
  m_generatedComparator.clear();

  std::string filenameToMock = boost::filesystem::path(p_fullPathToHeaderToMock).filename().string();
  fillInMacroDefinition(p_ctxt);
  fillInTemplateVariables(filenameToMock, p_ctxt);

  ctemplate::StringToTemplateCache(CFILE_TEMPLATE, templateText, ctemplate::DO_NOT_STRIP);
  ctemplate::StringToTemplateCache(HFILE_TEMPLATE, headerFileTemplate, ctemplate::DO_NOT_STRIP);
  ctemplate::StringToTemplateCache(COMPOSABLE_TYPE_DECLARE_TYPE_FIELD_OR_COMPOSABLE_TYPE_FIELD_TEMPLATE_NAME, composableType_DeclareTypeFieldOrComposableTypeField_template, ctemplate::DO_NOT_STRIP);
  ctemplate::StringToTemplateCache(COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_TEMPLATE_NAME, composableType_DeclareComposableType_template, ctemplate::DO_NOT_STRIP);
  ctemplate::StringToTemplateCache(EXTRA_DECL_TEMPLATE_NAME, extraDeclTemplate, ctemplate::DO_NOT_STRIP);
  ctemplate::StringToTemplateCache(EXTRA_TOP_DECL_TEMPLATE_NAME, extraTopDeclTemplate, ctemplate::DO_NOT_STRIP);

  std::string generatedCode;
  ctemplate::ExpandTemplate(CFILE_TEMPLATE, ctemplate::DO_NOT_STRIP, &dict, &generatedCode);
  if (!generateCodeToFile(p_outDir, filenameToMock, "c", generatedCode))
  {
    return false;
  }

  generatedCode.clear();
  ctemplate::ExpandTemplate(HFILE_TEMPLATE, ctemplate::DO_NOT_STRIP, &dict, &generatedCode);
  if (!generateCodeToFile(p_outDir, filenameToMock, "h", generatedCode))
  {
    return false;
  }

  return true;
}

void CodeGeneratorCTemplate::fillInMacroDefinition(const ElementToMockContext& p_elem)
{
  if(!m_generateUsedType)
  {
    return;
  }
  for(const auto& p : p_elem.getCrossDefinedMap())
  {
    std::string id = p.first;
    const MacroDefinition& macroDefinition = p.second;
    const std::string& definition = macroDefinition.getDefinition();
    const MacroDefinition::ParameterList& parameters = macroDefinition.getParameters();
    ctemplate::TemplateDictionary *macroSection = m_generateMockedTypeSection->AddSectionDictionary(GENERATED_MACRO_SECTION);

    macroSection->SetValue(GENERATED_MACRO_ID_VAR, id);
    macroSection->SetValue(ORIGIN_FILE_VAR, macroDefinition.getOriginFile());

    if(!parameters.empty())
    {
      ctemplate::TemplateDictionary *parametersSection = macroSection->AddSectionDictionary(GENERATED_MACRO_PARAMETERS_SECTION);
      std::string parametersStr{"("};
      bool first = true;
      for(const auto& param: parameters)
      {
        if(!first)
        {
          parametersStr.push_back(',');
        }
        parametersStr.append(param);
        first = false;
      }
      parametersStr.push_back(')');
      parametersSection->SetValue(GENERATED_MACRO_PARAMETERS_VAR, parametersStr);
    }

    if(!definition.empty())
    {
      ctemplate::TemplateDictionary* definitionSection = macroSection->AddSectionDictionary(GENERATED_MACRO_DEFINITION_SECTION);
      definitionSection->SetValue(GENERATED_MACRO_DEFINITION_VAR, definition);
    }
  }
}

void CodeGeneratorCTemplate::fillInTemplateVariables(const std::string &p_mockedHeader, const ElementToMockContext &p_ctxt)
{
  m_generateTypes.clear();
  m_generateForwardTypes.clear();
  m_lateDeclaration.clear();
  m_rootDictionary->SetValue(MOCKED_HEADER_FILENAME, p_mockedHeader);

  const auto& fList = p_ctxt.getElementToMock();
  std::string fileNameWithoutExtUpper = p_mockedHeader.substr(0, p_mockedHeader.find_last_of("."));
  std::transform(fileNameWithoutExtUpper.begin(), fileNameWithoutExtUpper.end(), fileNameWithoutExtUpper.begin(), ::toupper);
  m_rootDictionary->SetValue(MOCKED_FILE_NAME_WITHOUT_EXT_UPPER, fileNameWithoutExtUpper);
  std::unordered_set<std::size_t> generatedElements;
  for (const auto& elemToMock: fList)
  {
    switch (elemToMock->getMockType())
    {
      case ETS_function:
      {
        const FunctionDeclaration* fun = static_cast<const FunctionDeclaration*>(elemToMock);
        /*
         * In the case where the used types are generated, it is ok to create a mock for the function
         * since the original header is not used by the mock.
         */
        if((fun->isInlined() || fun->doesThisDeclarationHasABody() || fun->isStatic()) && !m_generateUsedType)
        {
          break;
        }
        if(m_mockOnlyList.size() > 0 && m_mockOnlyList.find(*fun->getName()) == m_mockOnlyList.end())
        {
          break;
        }
        /*
         * Sometimes, functions are aliased to other functions using macro. That creates double generation
         * of function. This ignores the generation of the aliased function.
         */
        if(p_ctxt.hasMacroDefine(*fun->getName()))
        {
          break;
        }
        /*
         * Abort the generation of the function if the used type aren't created.
         *
         * In the case of generated type, a dummy enum value is created.
         */
        if(doesFunctionUsesEmptyEnum(*fun) && !m_generateUsedType)
        {
          break;
        }
        /*
         * Function with attribute "noreturn" cannot be mocked when using the original header.
         * However, if the original header isn't used (m_generateUsedType == false), the mock can
         * be generated because the mock remove all the attributes.
         */
        const auto& funAttr = fun->getAttributes();
        const FunctionAttribute noReturnAttr{"noreturn"};
        if((std::find(funAttr.begin(), funAttr.end(), noReturnAttr) != std::end(funAttr)) && !m_generateUsedType)
        {
          break;
        }
        std::size_t rawHash = fun->getRawHash();
        if(generatedElements.find(rawHash) != generatedElements.end())
        {
          break;
        }
        generatedElements.insert(rawHash);
        generateFunctionSection(fun);
        break;
      }
      default:
        break;
    }
  }
  for(const auto composableType : m_lateDeclaration)
  {
    generateDeclarationOfUsedType(m_rootDictionary, composableType, true);
  }
}

void CodeGeneratorCTemplate::generateFunctionAttributes(const FunctionDeclaration *f, ctemplate::TemplateDictionary *functionSectionDict)
{
  const auto& functionAttributeList = f->getAttributes();
  for(const FunctionAttribute& funAttr : functionAttributeList)
  {
    if(std::find(m_generateAttrList.begin(), m_generateAttrList.end(), funAttr.getName()) == m_generateAttrList.end())
    {
      continue;
    }
    ctemplate::TemplateDictionary *funAttrSectionDict = functionSectionDict->AddSectionDictionary(FUNCTION_ATTR_LIST_SECTION);
    const std::string& name = funAttr.getName();
    funAttrSectionDict->SetValue(FUNCTION_ATTR_NAME_VAR, name);
    const auto& funAttrParams = funAttr.getParameters();
    if(!funAttrParams.empty())
    {
      ctemplate::TemplateDictionary *funAttrParamsList = funAttrSectionDict->AddSectionDictionary(FUNCTION_ATTR_PARAMETER_SECTION);
      for(const std::string& funAttrParam : funAttrParams)
      {
        ctemplate::TemplateDictionary *funAttrParamDict = funAttrParamsList->AddSectionDictionary(FUNCTION_ATTR_PARAMETER_LIST);
        funAttrParamDict->SetValue(FUNCTION_PARAM_NAME, funAttrParam);
      }
    }
  }
}

void CodeGeneratorCTemplate::generateFunctionSection(const FunctionDeclaration *p_elemToMock)
{
  ctemplate::TemplateDictionary *functionSectionDict = m_rootDictionary->AddSectionDictionary(FUNCTION_SECTION);
  if(m_generateUsedType)
  {
    /*
     * We do not need to fill in any value in this section because the variable in this section are the same
     * as for the parent and the value is propagated automatically over there
     */
    functionSectionDict->AddSectionDictionary(GENERATE_MOCKED_TYPE_SECTION);
  }
  functionSectionDict->SetValue(ORIGIN_FILE_VAR, p_elemToMock->getOriginFile());
  generateFunctionAttributes(p_elemToMock, functionSectionDict);
  functionSectionDict->SetValue(FUNCTION_STACK_VARIABLE_NAME, *p_elemToMock->getName());
  std::string upperString(*p_elemToMock->getName());
  std::transform(upperString.begin(), upperString.end(), upperString.begin(), ::toupper);
  functionSectionDict->SetValue(FUNCTION_NAME_UPPER, upperString);

  const ReturnValue *returnValue = p_elemToMock->getReturnType();
  const std::string returnTypeStr = getDeclaratorString(returnValue);
  std::string nonQualRetTypeStr = getNonQualifiedDeclaratorString(returnValue);
  functionSectionDict->SetValue(FUNCTION_RETURN_VALUE, returnTypeStr);
  functionSectionDict->SetValue(FUNCTION_TO_RETURN_VALUE, returnTypeStr);
  const TypeItf* rvType = returnValue->getType();
  /*
   * We need to register the typedef here for return value because we never call getRaw type which automatically
   * register a typedef whenever it encounters one.
   */
  registerTypeDef(rvType);
  generateDeclarationOfUsedType(m_rootDictionary, rvType, false);
  const Pointer *nonQualifiedReturnValuePointer = rvType->unqualify()->asPointer();
  functionSectionDict->SetValue(FUNCTION_NON_QUALIFIED_RETURN_VALUE, nonQualRetTypeStr);
  if(nonQualifiedReturnValuePointer)
  {
    const TypeItf *returnValuePointerPointedType = getRawType(nonQualifiedReturnValuePointer);
    const FunctionType *functionType = returnValuePointerPointedType->asFunctionType();
    if(functionType)
    {
      generateDeclarationOfUsedType(m_rootDictionary, functionType, false);
      generateExtraDecl(functionSectionDict, EXTRA_TOP_LEVEL_DECL_SECTION, EXTRA_TOP_DECL_TEMPLATE_NAME, functionType);
    }
  }

  bool isRvVoid = rvType->isCType() && rvType->getCType() == CTYPE_VOID && !rvType->unqualify()->isPointer();
  if (!isRvVoid)
  {
    ctemplate::TemplateDictionary *returnValParamDict = functionSectionDict->AddSectionDictionary(FUNCTION_RETURN_VALUE_PARAM_SECTION);
    returnValParamDict->SetValue(FUNCTION_NON_QUALIFIED_RETURN_VALUE, nonQualRetTypeStr);
    if(nonQualifiedReturnValuePointer)
    {
      const TypeItf *returnValuePointerPointedType = getRawType(nonQualifiedReturnValuePointer);
      const FunctionType *functionType = returnValuePointerPointedType->asFunctionType();
      if(functionType)
      {
        generateDeclarationOfUsedType(m_rootDictionary, functionType, false);
        generateExtraDecl(returnValParamDict, EXTRA_DECL_SECTION, EXTRA_DECL_TEMPLATE_NAME, functionType);
      }
      returnValParamDict->SetValue(FUNCTION_NON_QUALIFIED_RETURN_VALUE, nonQualRetTypeStr);
    }
  }
  const Parameter::Vector& funParams = p_elemToMock->getFunctionsParameters();
  generateFunctionParamSection(functionSectionDict, funParams);
  if(p_elemToMock->isVariadic())
  {
    ctemplate::TemplateDictionary *variadicSection = functionSectionDict->AddSectionDictionary(VARIADIC_SECTION);
    std::string variadicString;
    if(funParams.size() > 0)
    {
      variadicString.append(", ");
    }
    variadicString.append("...");
    variadicSection->SetValue(VARIADIC_VAR, variadicString);
  }
}

void CodeGeneratorCTemplate::generateExtraDecl(ctemplate::TemplateDictionary *dict, const char *sectionName, const char *templateFileName, const FunctionType *functionType)
{
  generateDeclarationOfUsedType(m_rootDictionary, functionType, false);

  ctemplate::TemplateDictionary *extraDeclDict = dict->AddIncludeDictionary(sectionName);
  extraDeclDict->SetFilename(templateFileName);

  generateFunctionParamSection(extraDeclDict, functionType->getFunctionsParameters());

  const ReturnValue *rv = functionType->getReturnType();
  const TypeItf *returnValueType = rv->getType();
  const Pointer *nonQualifiedReturnValueTypePointer = returnValueType->unqualify()->asPointer();
  if(nonQualifiedReturnValueTypePointer)
  {
    const TypeItf *returnValuePointedType = getRawType(nonQualifiedReturnValueTypePointer);
    const FunctionType *recursiveFunctionType = returnValuePointedType->asFunctionType();
    if(recursiveFunctionType)
    {
      ctemplate::TemplateDictionary *inInDict = extraDeclDict->AddSectionDictionary(std::string(sectionName) + "INSIDE");
      generateExtraDecl(inInDict, sectionName, templateFileName, recursiveFunctionType);
    }
  }
}

void CodeGeneratorCTemplate::generateFunctionParamSection(ctemplate::TemplateDictionary *p_functionSectionDict, const Parameter::Vector& p_functionParam)
{
  bool ptrSectionAdded = false;
  if (p_functionParam.size() > 0)
  {
    //This specific section to show the comma ',' conditionally for the expect and return function generation
    p_functionSectionDict->AddSectionDictionary(FUNCTION_PARAM_LIST_SECTION);
  }
  for (Parameter::Vector::const_iterator it = p_functionParam.begin(); it != p_functionParam.end(); ++it)
  {
    ctemplate::TemplateDictionary* newTypedefParamSection = p_functionSectionDict->AddSectionDictionary(FUNCTION_PARAM_SECTION);
    const Parameter *fParam = *it;
    const TypeItf *paramType = fParam->getType();
    generateDeclarationOfUsedType(m_rootDictionary, paramType, false);
    //For the rest of this function nonQualifiedParamPtrType tells whether we are dealing with a pointer parameter or not
    const std::string argType = getDeclaratorString(fParam);
    const std::string nonQualifiedArgType = getNonQualifiedDeclaratorString(fParam);
    const TypeItf* rawType = getRawType(paramType);
    const Pointer* nonQualifiedParamPtrType = paramType->unqualify()->asPointer();
    const ComposableType* composableType = rawType->asComposableType();
    if(composableType && !rawType->isImplicit())
    {
      std::string prepend { "" };
      std::string declare { "" };
      std::string typedefName { getTypeDefName(paramType) };
      generateComposedTypedCompareSection(composableType, prepend, declare);
    }
    newTypedefParamSection->SetValue(FUNCTION_PARAM_TYPE, argType);
    if(!nonQualifiedParamPtrType)
    {
      newTypedefParamSection->SetValue(FUNCTION_PARAM_NON_QUALIFIED_TYPE, nonQualifiedArgType);
    }
    else
    {
      newTypedefParamSection->SetValue(FUNCTION_PARAM_NON_QUALIFIED_TYPE, argType);
      const TypeItf *paramPtrPointedType = getRawType(nonQualifiedParamPtrType);
      const FunctionType *ft = paramPtrPointedType->asFunctionType();
      if(ft)
      {
        generateDeclarationOfUsedType(m_rootDictionary, ft, false);
        generateExtraDecl(newTypedefParamSection, EXTRA_DECL_SECTION, EXTRA_DECL_TEMPLATE_NAME, ft);
      }
    }
    std::string paramName = fParam->getName();
    if(paramName.empty())
    {
      paramName.append("__easymock_param" + std::to_string(m_nbUnamedParam));
      m_nbUnamedParam++;
    }
    newTypedefParamSection->SetValue(FUNCTION_PARAM_NAME, paramName);
    // For easyMock_matcher_*
    newTypedefParamSection->SetValue(FUNCTION_MATCHER_PARAM_NAME, paramName);

    /*
     * Do not generate the output parameter for pointers to const value.
     * Do not generate the output parameter for implicit type (i.e. va_args).
     *    I can't possibly think why it would be useful, and I'm not even
     *    sure that it is even possible or sensible.
     * Do not generate the output parameter for function type.
     *    Output function pointer doesn't make sense.
     */
    if(nonQualifiedParamPtrType)
    {
      const TypeItf* pointedType = nonQualifiedParamPtrType->getMostPointedType();
      if(!pointedType->isConst() &&
         !pointedType->isImplicit() &&
         !pointedType->isFunctionType())
      {
        if(!ptrSectionAdded)
        {
          p_functionSectionDict->AddSectionDictionary(FUNCTION_PARAM_PTR_LIST_SECTION);
          ptrSectionAdded = true;
        }
        ctemplate::TemplateDictionary* newPtrParamSection = p_functionSectionDict->AddSectionDictionary(FUNCTION_PARAM_PTR_SECTION);
        //No need to add the FUNCTION_PARAM_NON_QUALIFIED_TYPE because we will not generate output pointer for const
        newPtrParamSection->SetValue(FUNCTION_PARAM_TYPE, argType);
        newPtrParamSection->SetValue(FUNCTION_PARAM_NAME, paramName);
        ctemplate::TemplateDictionary* subdict = nullptr;
        if(pointedType->getCType() == CTYPE_VOID)
        {
          subdict = newPtrParamSection->AddSectionDictionary(FUNCTION_VOID_PTR_OUT_SECTION);
        }
        else
        {
          subdict = newPtrParamSection->AddSectionDictionary(FUNCTION_NON_VOID_PTR_OUT_SECTION);
        }
        subdict->SetValue(FUNCTION_PARAM_TYPE, argType);
        subdict->SetValue(FUNCTION_PARAM_NAME, paramName);
      }
    }
  }
}

/*
 * e.g
  int cmp_struct_s ( void *currentCall_ptr, void *expectedCall_ptr, const char *paramName, char *errorMessage ) {
  struct s currentCall_val = *(( struct s *)currentCall_ptr);
  struct s expectedCall_val = *(( struct s *)expectedCall_ptr);
  if(currentCall_val.f1 != expectedCall_val.f1) {
    snprintf(errorMessage, 256 , "Parameter '%s' has field f1 with value '" "%c" "', was expecting '" "%c" "'", paramName, currentCall_val.f1, expectedCall_val.f1);
    return -1;
  }
  if(currentCall_val.f2 != expectedCall_val.f2) {
    snprintf(errorMessage, 256 , "Parameter '%s' has field f2 with value '" "%c" "', was expecting '" "%c" "'", paramName, currentCall_val.f1, expectedCall_val.f1);
    return -1;
  }
  if(cmp_struct_s2 (&currentCall_val.f3, expectedCall_val.f3, "f3", errorMessage) != 0)
  {
    return -1;
  }
  return 0;
}
 * TEMPLATED VERSION
{{BEGIN_COMPOSED_TYPE_COMPARE_SECTION}}
  int cmp_struct_{{STRUCT_NAME}} ( void *currentCall_ptr, void *expectedCall_ptr, const char *paramName, char *errorMessage ) {
  struct {{STRUCT_NAME}} currentCall_val = *(( struct {{STRUCT_NAME}} *)currentCall_ptr);
  struct {{STRUCT_NAME}} expectedCall_val = *(( struct {{STRUCT_NAME}} *)expectedCall_ptr);
  {{BEGIN_STRUCT_COMPARE_PARAM_SECTION}}
  if({{COMPARE_CONDITION}}) {
    {{BEGIN_STRUCT_COMPARE_ERROR}}
    snprintf(errorMessage, 256 , "Parameter '%s' which is a struct of type {{STRUCT_COMPARE_TYPE}} has field {{STRUCT_COMPARE_FIELD}} with value '" "%{{STRUCT_COMPARE_PRINTF_FORMAT}}" "', was expecting '" "%{{STRUCT_COMPARE_PRINTF_FORMAT}}" "'", paramName, currentCall_val.{{STRUCT_COMPARE_FIELD}}, expectedCall_val.{{STRUCT_COMPARE_FIELD}});
    {{END_STRUCT_COMPARE_ERROR}}
    return -1;
  }
  {{END_STRUCT_COMPARE_PARAM_SECTION}}
  return 0;
}
{{END_COMPOSED_TYPE_COMPARE_SECTION}}
 */

void CodeGeneratorCTemplate::generateFieldCmp(std::string& p_condition, const ComposableType *p_parentComposedType, const ComposableFieldItf *p_curField, const ComposableFieldItf *p_previousField, std::string p_varName)
{
  const ComposableField *curComposableField = dynamic_cast<const ComposableField*>(p_curField);
  if(p_curField->isAnonymous())
  {
    if(p_previousField)
    {
      p_condition.append("(char*)&");
      p_condition.append(p_varName);
      p_condition.append("->");
      p_condition.append(p_previousField->getName());
      /*
       * If the parent composable type is an union, we do not need to add sizeof
       * because all of the elements of the union have the same base address
       */
      if(!p_parentComposedType->isUnion())
      {
        p_condition.append(" + sizeof(");
        p_condition.append(p_varName);
        p_condition.append("->");
        p_condition.append(p_previousField->getName());
        p_condition.append(")");
      }
    }
    else
    {
      /*
       * This anonymous composable type is the first field of the parent
       * composable type, so we just give the pointer as is
       */
      p_condition.append(p_varName);
    }
  }
  else
  {
    p_condition.push_back('&');
    p_condition.append(p_varName);
    p_condition.append("->");
    p_condition.append(p_curField->getName());
  }
  if(curComposableField && curComposableField->isBoundSpecifiedArray())
  {
    p_condition.append("[idx]");
  }
}

void CodeGeneratorCTemplate::generateBodyStructCompare(ctemplate::TemplateDictionary *p_compareFunDict, const char* p_ctemplateDictionarySectionToAdd, const ComposableType *p_parentComposedType, const ComposableFieldItf *p_curField, const ComposableFieldItf *p_previousField, std::string p_uniquePrepend, std::string p_declPrepend)
{
  auto addCtemplateDictionarySubSection = [](ctemplate::TemplateDictionary *p_compareFunDict, const char* p_ctemplateDictionarySectionToAdd, const ComposableFieldItf *p_curField)
  {
    ctemplate::TemplateDictionary *newDict = p_compareFunDict->AddSectionDictionary(p_ctemplateDictionarySectionToAdd);
    if(std::strcmp(p_ctemplateDictionarySectionToAdd, STRUCT_COMPARE_ARRAY_SECTION) == 0)
    {
      newDict->SetValue(STRUCT_COMPARE_FIELD, p_curField->getName());
    }
    return newDict;
  };
  static unsigned int s_nbAnonymousField = 0;

  const TypeItf* curFieldType = p_curField->getType();
  const TypeItf* unqualType = curFieldType->unqualify();
  const bool isPointer = unqualType->isPointer();
  const TypeItf* rawCurFieldType = getRawType(curFieldType);
  const ComposableType* curFieldComposableType = rawCurFieldType->asComposableType();
  const IncompleteType* incompleteType = rawCurFieldType->asIncompleteType();

  if((curFieldComposableType  && !isPointer) || (incompleteType && !isPointer))
  {
    const bool isFieldAnonymous = p_curField->isAnonymous();
    if(isFieldAnonymous)
    {
      p_uniquePrepend.push_back('_');
      if(p_declPrepend.back() == ':')
      {
        p_declPrepend.append("<anonymous>");
      }
      p_declPrepend.append("::");
      assert(curFieldComposableType);
      generateAllFieldStructCompare(p_compareFunDict, curFieldComposableType, p_uniquePrepend, p_declPrepend);
    }
    else
    {
      ctemplate::TemplateDictionary *paramSectDict = addCtemplateDictionarySubSection(p_compareFunDict, p_ctemplateDictionarySectionToAdd, p_curField);
      ctemplate::TemplateDictionary *ifPreSectionDict = paramSectDict->AddSectionDictionary(STRUCT_COMPARE_PRE_IF_SECTION);

      std::string preFieldVarName("");
      if(p_curField->isAnonymous())
      {
        preFieldVarName.append("parameter_");
        preFieldVarName.append(std::to_string(s_nbAnonymousField));
        s_nbAnonymousField++;
      }
      else
      {
        preFieldVarName.append(p_curField->getName());
        preFieldVarName.append("_parameter");
        std::string ifSectionFieldName(".");
        ifSectionFieldName.append(p_curField->getName());
        ifPreSectionDict->SetValue(STRUCT_COMPARE_PRE_IF_SECTION_FIELD_NAME, ifSectionFieldName);
      }
      ifPreSectionDict->SetValue(STRUCT_COMPARE_PRE_IF_SECTION_VAR_NAME, preFieldVarName.c_str());
      std::string condition { "" };
      condition.append("cmp_");
      if(curFieldComposableType && curFieldComposableType->isDeclarationEmbeddedInOtherType() && p_uniquePrepend.size() > 0)
      {
        condition.append(p_uniquePrepend);
        condition.push_back('_');
      }
      if(curFieldComposableType)
      {
        condition.append(getComparatorName(curFieldComposableType));
      }
      if(incompleteType)
      {
        condition.append(getComparatorName(incompleteType));
      }
      condition.push_back('(');
      generateFieldCmp(condition, p_parentComposedType, p_curField, p_previousField, "currentCall_val");
      condition.append(", ");
      generateFieldCmp(condition, p_parentComposedType, p_curField, p_previousField, "expectedCall_val");
      condition.append(", cstring_c_str(&");
      condition.append(preFieldVarName);
      condition.append("), errorMessage)");

      p_uniquePrepend.push_back('_');
      p_declPrepend.append("::");
      if(curFieldComposableType)
      {
        generateComposedTypedCompareSection(curFieldComposableType, p_uniquePrepend, p_declPrepend);
      }

      paramSectDict->SetValue(COMPARE_CONDITION, condition);
    }
  }
  else if (
    rawCurFieldType->isCType()
    || rawCurFieldType->isFunctionType()
    || rawCurFieldType->isEnum()
    || isPointer
    || rawCurFieldType->isIncompleteType()
    || rawCurFieldType->isConst()
          )
  {
    ctemplate::TemplateDictionary *paramSectDict = addCtemplateDictionarySubSection(p_compareFunDict, p_ctemplateDictionarySectionToAdd, p_curField);
    generateBasicTypeField(p_curField, paramSectDict, p_parentComposedType, p_declPrepend);
  }
  else
  {
    std::fprintf(stderr, "%s: Type '%s' unexpected here. Contact owner for bug fixing\n\r", __FUNCTION__, rawCurFieldType->getFullDeclarationName().c_str());
    assert(false);
  }
}

void CodeGeneratorCTemplate::setStructCompareStringFormat(ctemplate::TemplateDictionary *p_errorDict, const TypeItf* p_curFieldType)
{
  p_curFieldType = getUnqualifiedAndUntypedefType(p_curFieldType);

  if(p_curFieldType->unqualify()->isPointer() || p_curFieldType->isIncompleteType() || p_curFieldType->isFunctionType())
  {
    p_errorDict->SetValue(STRUCT_COMPARE_PRINTF_FORMAT, "p");
  }
  else if(p_curFieldType->isEnum())
  {
    p_errorDict->SetValue(STRUCT_COMPARE_PRINTF_FORMAT, "d");
  }
  else if(p_curFieldType->isCType())
  {
    p_errorDict->SetValue(STRUCT_COMPARE_PRINTF_FORMAT, easyMock_printfFormat[p_curFieldType->getCType()]);
  }
  else
  {
    std::fprintf(stderr, "%s: Type '%s' unexpected here. Contact owner for bug fixing\n\r", __FUNCTION__, p_curFieldType->getFullDeclarationName().c_str());
    assert(false);
  }
}

void CodeGeneratorCTemplate::generateBasicTypeField(const ComposableFieldItf *p_curField, ctemplate::TemplateDictionary *p_paramSectDict, const ComposableType *p_composedType, std::string p_declPrepend)
{
  const ComposableField* curComposableField = dynamic_cast<const ComposableField*>(p_curField);
  std::string condition;
  condition.append("currentCall_val->");
  condition.append(p_curField->getName());
  if(curComposableField && curComposableField->isBoundSpecifiedArray())
  {
    condition.append("[idx]");
  }
  condition.append(" != expectedCall_val->");
  condition.append(p_curField->getName());
  if(curComposableField && curComposableField->isBoundSpecifiedArray())
  {
    condition.append("[idx]");
  }
  ctemplate::TemplateDictionary *errorDict = p_paramSectDict->AddSectionDictionary(STRUCT_COMPARE_ERROR);
  std::string compareField = p_curField->getName();
  if(curComposableField && curComposableField->isBoundSpecifiedArray())
  {
    errorDict->AddSectionDictionary(STRUCT_PRINT_IDX_SECTION); //This section needs to be added only once
    compareField.append("[idx]");
  }
  errorDict->SetValue(STRUCT_COMPARE_FIELD, compareField);
  std::string compareType;
  if(!p_composedType->isDeclarationEmbeddedInOtherType())
  {
    const std::string& composedTypeName = p_composedType->getName();
    const std::string& composedTypedefNamed = getTypeDefName(p_composedType);
    if(!composedTypedefNamed.empty())
    {
      compareType.append(composedTypedefNamed);
    }
    else
    {
      compareType.append(composedTypeName);
    }
  }
  else
  {
    compareType.append(p_declPrepend);
    if(p_composedType->isAnonymous())
    {
      compareType.append("<anonymous>");
    }
  }
  errorDict->SetValue(STRUCT_COMPARE_TYPE, compareType);
  const TypeItf *curFieldType = p_curField->getType();
  setStructCompareStringFormat(errorDict, curFieldType);
  p_paramSectDict->SetValue(COMPARE_CONDITION, condition);
}

void CodeGeneratorCTemplate::generateDeclarationOfUsedType(ctemplate::TemplateDictionary* p_parentDictionary, const TypeItf* p_type, bool p_generateIncomplete)
{
  if(!m_generateUsedType)
  {
    return;
  }
  if(!m_generateMockedTypeSection)
  {
    std::fprintf(stderr, "%s: m_generateMockedTypeSection is nullptr. Contact owner for bug fixing\n\r", __FUNCTION__);
    assert(m_generateMockedTypeSection);
  }
  /*
   * If we are dealing with incomplete type or pointers we want to continue to
   * generate the type if needed. i.e. we shouldn't check isTypeGenerated.
   * Incomplete types needs the body to be generated.
   * Pointers types needs (potentially) their pointed type to be generated
   */
  const QualifiedType* qualifiedType = p_type->asQualifiedType();
  const Pointer* pointerType = p_type->asPointer();
  const IncompleteType* incompleteType = p_type->asIncompleteType();
  const ComposableType* composableType = p_type->asComposableType();
  const TypedefType *typedefType = p_type->asTypedefType();
  const FunctionType* functionType = p_type->asFunctionType();
  const Enum* enumType = p_type->asEnum();
  if((!incompleteType && !pointerType && !qualifiedType && !functionType) && isTypeGenerated(p_type, true))
  {
    return;
  }

  if(incompleteType)
  {
    generateForwardDeclaration(incompleteType);
  }
  else if(composableType)
  {
    if(isComposableTypeComplete(composableType) || p_generateIncomplete)
    {
      generateForwardDeclaration(composableType);

      /*
       * 1. Generate the contained field's type
       */
      for (const ComposableFieldItf *fItf: composableType->getContainedFields())
      {
        if (fItf->isComposableField())
        {
          const ComposableField *composableField = dynamic_cast<const ComposableField *>(fItf);
          const TypeItf *composableFieldType = composableField->getType();
          bool isParentRoot = p_parentDictionary == m_rootDictionary;
          if (!isParentRoot && composableFieldType->isAnonymous() && composableFieldType->isComposableType())
          {
            /*
             * For anonymous composable type generate the code inline because
             * it doesn't make sense to create the anonymous type outside.
             */
            generateDeclarationOfComposableType(p_parentDictionary,
                                                dynamic_cast<const ComposableType *>(composableFieldType), -1,
                                                GenerateDeclarationOfComposableTypeOrigin::GENERATE_SUB_LEVEL_USED_TYPE);
          } else
          {
            generateDeclarationOfUsedType(p_parentDictionary, composableFieldType, false);
          }
        }
      }
      /*
       * 2. Generate the current type
       */
      ctemplate::TemplateDictionary *generatedType_section = p_parentDictionary->AddSectionDictionary(
          GENERATED_TYPE_SECTION);
      std::string guardName{composableType->getComposableTypeKeyword()};
      const std::string &typeName = p_type->getName();
      std::string finalTypeName{typeName};
      if (finalTypeName.empty())
      {
        finalTypeName = getAnonymousTypedefUniqueName(p_type);
      }
      guardName.append(finalTypeName);
      generatedType_section->SetValue(GENERATED_TYPE_DECLARE_TYPENAME_VAR, guardName);
      generateDeclarationOfComposableType(generatedType_section, composableType, 1,
                                          GenerateDeclarationOfComposableTypeOrigin::GENERATE_TOP_LEVEL_USED_TYPE);
    }
    else
    {
      assert(!p_generateIncomplete);
      m_generateTypes.erase(p_type);
      m_lateDeclaration.push_back(composableType);
    }
  }
  else if(typedefType)
  {
    generateSimpleTypeDef(typedefType);
    generateDeclarationOfUsedType(p_parentDictionary, typedefType->getTypee(), false);
  }
  else if(enumType)
  {
    generateEnum(p_type);
  }
  else if(qualifiedType)
  {
    generateDeclarationOfUsedType(p_parentDictionary, qualifiedType->getUnqualifiedType(), false);
  }
  else if(pointerType)
  {
    generateDeclarationOfUsedType(p_parentDictionary, pointerType->getPointedType(), false);
  }
  else if(functionType)
  {
    generateDeclarationOfUsedType(p_parentDictionary, functionType->getReturnType()->getType(), false);
    for(const auto& param:functionType->getFunctionsParameters())
    {
      generateDeclarationOfUsedType(p_parentDictionary, param->getType(), false);
    }
  }
  else
  {
    return;
  }
}

void CodeGeneratorCTemplate::generateForwardDeclaration(const TypeItf *p_type)
{
  if(!m_generateUsedType)
  {
    return;
  }
  if(p_type->getName().empty())
  {
    return;
  }
  if(m_generateForwardTypes.find(p_type) != m_generateForwardTypes.end())
  {
    return;
  }
  m_generateForwardTypes.insert(p_type);

  std::string typeVar;
  {
    const IncompleteType *incompleteType = p_type->asIncompleteType();
    const ComposableType *composableType = p_type->asComposableType();
    if (incompleteType)
    {
      typeVar = std::string{incompleteType->getComposableTypeKeyword()};
    } else if (composableType)
    {
      typeVar = std::string{composableType->getComposableTypeKeyword()};
    } else
    {
      return;
    }
  }
  assert(m_generateMockedTypeSection);
  ctemplate::TemplateDictionary *forwardDeclaration_section = m_generateMockedTypeSection->AddSectionDictionary(GENERATED_TYPE_FORWARD_DECLARATION_SECTION);
  forwardDeclaration_section->SetValue(COMPOSABLE_TYPE_DECLARATION_TYPE_VAR, typeVar);
  forwardDeclaration_section->SetValue(COMPOSABLE_TYPE_TYPE_NAME_VAR, p_type->getName());

  ctemplate::TemplateDictionary *anonymousDeclDict = forwardDeclaration_section->AddIncludeDictionary(COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_SECTION);
  anonymousDeclDict->SetFilename(COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_TEMPLATE_NAME);
  anonymousDeclDict->SetValue(COMPOSABLE_TYPE_DECLARATION_TYPE_VAR, typeVar);
  anonymousDeclDict->SetValue(COMPOSABLE_TYPE_TYPE_NAME_VAR, p_type->getName());
}

ctemplate::TemplateDictionary* CodeGeneratorCTemplate::generateDeclarationOfComposableType(ctemplate::TemplateDictionary* p_curFieldDict, const ComposableType* p_composedType, int p_nbLevelToGenerate, CodeGeneratorCTemplate::GenerateDeclarationOfComposableTypeOrigin p_origin)
{
  const bool isStructOfExistingType = p_origin == GenerateDeclarationOfComposableTypeOrigin::GENERATE_COMPARE_FUNCTION && !p_composedType->isDeclarationEmbeddedInOtherType();
  const bool generateBody = p_nbLevelToGenerate != 0 && !isStructOfExistingType;
  const bool generateName = p_origin == GenerateDeclarationOfComposableTypeOrigin::GENERATE_COMPARE_FUNCTION ||
                            p_origin == GenerateDeclarationOfComposableTypeOrigin::GENERATE_TOP_LEVEL_USED_TYPE ||
                            !generateBody;
  ctemplate::TemplateDictionary *anonymousDeclDict = p_curFieldDict->AddIncludeDictionary(COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_SECTION);
  anonymousDeclDict->SetFilename(COMPOSABLE_TYPE_DECLARE_COMPOSABLE_TYPE_TEMPLATE_NAME);

  /*
   * 1. Generate the keyword "struct" or "union"
   */
  std::string typeVar {p_composedType->getComposableTypeKeyword()};
  anonymousDeclDict->SetValue(COMPOSABLE_TYPE_DECLARATION_TYPE_VAR, typeVar);

  /*
   * 2. Generate the name of the structure
   */
  if(generateName)
  {
    std::string name { p_composedType->getName() };
    if(name.empty())
    {
      name = getAnonymousName(p_composedType);
    }
    anonymousDeclDict->SetValue(COMPOSABLE_TYPE_TYPE_NAME_VAR, name);
  }

  /*
   * Do not go further if the type has already been generated
   */
  if(!generateBody && isTypeGenerated(p_composedType, false))
  {
    return anonymousDeclDict;
  }

  /*
   * 3. Generate the body
   */
  const ComposableFieldItf::Vector& vectField = p_composedType->getContainedFields();
  ctemplate::TemplateDictionary* typeBodyDictionnary { nullptr };
  typeBodyDictionnary = anonymousDeclDict->AddSectionDictionary(COMPOSABLE_TYPE_BODY_SECTION);
  for (const auto& curField : vectField)
  {
    const TypeItf* fieldType = curField->getType();
    const ComposableType* composableType = fieldType->asComposableType();

    ctemplate::TemplateDictionary *curFieldDict = typeBodyDictionnary->AddIncludeDictionary(COMPOSABLE_TYPE_DECLARE_TYPE_FIELD_OR_COMPOSABLE_TYPE_FIELD_SECTION);
    curFieldDict->SetFilename(COMPOSABLE_TYPE_DECLARE_TYPE_FIELD_OR_COMPOSABLE_TYPE_FIELD_TEMPLATE_NAME);

    if(composableType)
    {
      std::string curFieldName = curField->getName();
      int nextNbLevelToGenerate = p_nbLevelToGenerate == 0 ? 0 : p_nbLevelToGenerate - 1;
      GenerateDeclarationOfComposableTypeOrigin nextOrigin =
              p_origin == GenerateDeclarationOfComposableTypeOrigin::GENERATE_TOP_LEVEL_USED_TYPE ||
              p_origin == GenerateDeclarationOfComposableTypeOrigin::GENERATE_COMPARE_FUNCTION ?
              GenerateDeclarationOfComposableTypeOrigin::GENERATE_SUB_LEVEL_USED_TYPE : p_origin;
      if(fieldType->isAnonymous())
      {
        nextNbLevelToGenerate++;
      }
      ctemplate::TemplateDictionary* subAnonymousDeclDict = generateDeclarationOfComposableType(curFieldDict, composableType, nextNbLevelToGenerate, nextOrigin);
      if(!curFieldName.empty())
      {
        const ComposableField* curCompField = dynamic_cast<const ComposableField*>(curField);
        if(curCompField && curCompField->isBoundSpecifiedArray())
        {
          curFieldName.push_back('[');
          curFieldName.append(std::to_string(curCompField->getArraySize()));
          curFieldName.push_back(']');
        }
        subAnonymousDeclDict->AddSectionDictionary(COMPOSABLE_TYPE_INLINE_DECL_FIELD_NAME_SECTION)->SetValue(COMPOSABLE_TYPE_INLINE_DECL_FIELD_NAME_VAR, curFieldName);
      }
    }
    else
    {
      const ComposableField* curCompField = dynamic_cast<const ComposableField*>(curField);
      ctemplate::TemplateDictionary *curFieldValDict = curFieldDict->AddSectionDictionary(COMPOSABLE_TYPE_DECLARE_TYPE_SECTION);
      std::string declaredString = getDeclaratorString(curField);
      curFieldValDict->SetValue(TYPE_DECLARATION_VAR, declaredString);
      const std::string& curFieldName = curField->getName();
      std::string fieldName = curFieldName;
      generateSimpleTypeDef(getMostPointedType(curField->getType()));
      if(curCompField && curCompField->isBoundSpecifiedArray())
      {
        fieldName.push_back('[');
        fieldName.append(std::to_string(curCompField->getArraySize()));
        fieldName.push_back(']');
      }
      if(curField->isComposableBitfield())
      {
        const ComposableBitfield *curComposableBitfield = dynamic_cast<const ComposableBitfield*>(curField);
        fieldName.push_back(':');
        fieldName.append(std::to_string(curComposableBitfield->getSize()));
      }
      curFieldValDict->SetValue(TYPE_NAME_VAR, fieldName);
      const Pointer* nonQualifiedFieldPtrType = fieldType->unqualify()->asPointer();
      if(nonQualifiedFieldPtrType)
      {
        const FunctionType *ft = getRawType(nonQualifiedFieldPtrType)->asFunctionType();
        if (ft)
        {
          generateDeclarationOfUsedType(m_rootDictionary, ft, false);
          generateExtraDecl(curFieldDict, EXTRA_DECL_SECTION, EXTRA_DECL_TEMPLATE_NAME, ft);
        }
      }
      generateEnum(fieldType);
    }
  }
  return anonymousDeclDict;
}

void CodeGeneratorCTemplate::generateComposedTypedCompareSection(const ComposableType *p_composedType, std::string p_uniquePrepend, std::string p_declPrepend)
{

  std::string uniqueName {getComparatorName(p_composedType) };

  //Generate each comparator only once.
  if(m_generatedComparator.find(uniqueName) != m_generatedComparator.end())
  {
    return;
  }
  m_generatedComparator.insert(uniqueName);

  if(p_composedType->isDeclarationEmbeddedInOtherType())
  {
    if(!(p_uniquePrepend.size() == 1 && p_uniquePrepend[0] == '_'))
    {
      uniqueName = p_uniquePrepend + uniqueName;
    }
  }

  const std::string& composableTypeName = getMostDefinedName(p_composedType);
  p_declPrepend.append(composableTypeName);

  ctemplate::TemplateDictionary *compareDict = m_rootDictionary->AddSectionDictionary(COMPOSED_TYPE_COMPARE_SECTION);

  //Take care of generating the declaration of the anonymous type within the scope of the compare function
  if(p_composedType->isAnonymous() && p_composedType->isDeclarationEmbeddedInOtherType())
  {
    generateDeclarationOfComposableType(compareDict, p_composedType, -1, CodeGeneratorCTemplate::GenerateDeclarationOfComposableTypeOrigin::GENERATE_COMPARE_FUNCTION);
  }

  /*
   * Generate "an union" iso "a union"
   */
  std::string composedType { p_composedType->getComposableTypeKeyword() };
  if(composedType[0] == 'a' || composedType[0] == 'e' || composedType[0] == 'i' || composedType[0] == 'o' || composedType[0] == 'u')
  {
    composedType = std::string { "n " } + composedType;
  }
  else
  {
    composedType = std::string {" " } + composedType;
  }
  compareDict->SetValue(COMPOSED_TYPE_VAR, composedType);

  std::string declarationString { getTypeDefName(p_composedType) };
  if(declarationString.empty()) //I.e It is not typedef
  {
    if(p_composedType->isAnonymous())
    {
      declarationString.append(p_composedType->getComposableTypeKeyword());
      declarationString.push_back(' ');
      declarationString.append(getAnonymousTypedefUniqueName(p_composedType));
    }
    else
    {
      declarationString.append(p_composedType->getFullDeclarationName());
    }
  }
  std::string constDeclString { "const "};
  constDeclString.append(declarationString);
  compareDict->SetValue(COMPOSED_TYPED_DECL_STRING, constDeclString);
  compareDict->SetValue(COMPOSED_TYPED_UNIQUE_NAME, uniqueName);

  generateAllFieldStructCompare(compareDict, p_composedType, p_uniquePrepend, p_declPrepend);
}

void CodeGeneratorCTemplate::generateAllFieldStructCompare(ctemplate::TemplateDictionary *p_compareFunDict, const ComposableType *p_composedType, std::string p_uniquePrepend, std::string p_declPrepend)
{
  const ComposableFieldItf::Vector& vectField = p_composedType->getContainedFields();
  const ComposableFieldItf *prevField = nullptr;
  for (ComposableFieldItf::Vector::const_iterator it = vectField.begin(); it != vectField.end(); ++it)
  {
    const ComposableFieldItf *curFieldItf = *it;
    const ComposableField *curComposableField = dynamic_cast<const ComposableField*>(curFieldItf);
    if(curComposableField && curComposableField->isBoundSpecifiedArray())
    {
      generateBodyStructCompare(p_compareFunDict, STRUCT_COMPARE_ARRAY_SECTION, p_composedType, curFieldItf, prevField, p_uniquePrepend, p_declPrepend);
    }
    else
    {
      const bool isNonAnonymousBitfield = !curFieldItf->getName().empty() && curFieldItf->isComposableBitfield();
      const bool isGeneratableField = curComposableField && !curComposableField->isUnboundSpecifiedArray();
      if(isNonAnonymousBitfield || isGeneratableField)
      {
        //simple variable case
        generateBodyStructCompare(p_compareFunDict, STRUCT_COMPARE_PARAM_SECTION, p_composedType, curFieldItf, prevField, p_uniquePrepend, p_declPrepend);
      }
      //else {???} Since we do not know the how many element is in the array, we cannot generate any code for it
    }
    prevField = curComposableField;
  }
}

bool CodeGeneratorCTemplate::generateCodeToFile(const std::string &p_outDir, const std::string &p_filename, const std::string &p_extension, const std::string &p_generatedCode)
{
  bool rv = true;
  FILE *f = nullptr;
  std::string outFilename(p_outDir);
  outFilename.append("/" MOCK_FRAMEWORK_NAME "_");
  outFilename.append(p_filename.substr(0, p_filename.find_last_of(".")));
  outFilename.append(".");
  outFilename.append(p_extension);

  std::fprintf(stdout, "Generating %s", p_filename.c_str());
  if(p_extension.compare("h") == 0)
  {
    if(m_generateUsedType)
    {
      std::fprintf(stdout, " with using generated types ");
    }
    else
    {
      std::fprintf(stdout, " with using original headers ");
    }
  }
  else
  {
    std::fprintf(stdout, " ");
  }
  std::fprintf(stdout, "in %s\n\r", p_outDir.c_str());
  f = std::fopen(outFilename.c_str(), "w+");
  if (f == nullptr)
  {
    std::fprintf(stderr, "Error creating %s: %s", outFilename.c_str(), strerror(errno));
    rv = false;
    goto closeFile;
  }
  if (std::fprintf(f, "%s", p_generatedCode.c_str()) < 0)
  {
    std::fprintf(stderr, "Error writing into %s: %s", outFilename.c_str(), strerror(errno));
    rv = false;
    goto closeFile;
  }
closeFile:
  if (f != nullptr)
  {
    std::fclose(f);
  }

  return rv;
}

std::string CodeGeneratorCTemplate::getNonQualifiedDeclaratorString(const Declarator* p_decl)
{
  const TypeItf *typeToDeclare = p_decl->getType()->unqualify();
  return typeToDeclare->getFullDeclarationName();
}

std::string CodeGeneratorCTemplate::getDeclaratorString(const Declarator* p_decl)
{
  std::string rv { p_decl->getDeclareString() };
  const TypeItf* declType = p_decl->getType();
  const TypeItf* declRawType = getRawType(declType);
  /*
   * Only generate an anonymous type if the initial type wasn't a typedef.
   *
   * It is possible that a raw type is anonymous while it has been declared with a typedef.
   * e.g.
   * typedef struct
   * {
   *   int a;
   * }foo;
   *
   * void fun(foo a);
   *
   * The struct is anonymous, but it has been used using a typedef.
   *
   * containsTypeDef is used because it is needed to check the case where pointer to typedef
   * (or qualified typedef) are being used.
   */
  if(declRawType->isAnonymous() && !declType->containsTypeDef())
  {
    /*
     * If the type is anonymous, then we need something like
     * enum
     * So we must append the generated anonymous type name to it.
     */
    rv.append(" ");
    rv.append(getAnonymousName(declRawType));
  }
  return rv;
}

bool CodeGeneratorCTemplate::isTypeGenerated(const TypeItf* p_type, bool p_insert)
{
  const bool present = m_generateTypes.find(p_type) != m_generateTypes.end();
  if(!present && p_insert)
  {
    m_generateTypes.insert(p_type);
  }
  return present;
}

const TypeItf* CodeGeneratorCTemplate::getMostPointedType(const TypeItf* p_type)
{
  const Pointer* ptrType = p_type->asPointer();
  if(ptrType)
  {
    return ptrType->getMostPointedType();
  }
  return p_type;
}

void CodeGeneratorCTemplate::generateSimpleTypeDef(const TypeItf* p_type)
{
  const TypedefType *typedefType = p_type->asTypedefType();
  if(!typedefType)
  {
    return;
  }
  if(m_generatedTypeTypedDefSection.find(typedefType) != m_generatedTypeTypedDefSection.end())
  {
    return;
  }
  m_generatedTypeTypedDefSection.emplace(typedefType);

  const TypeItf* typeeType = typedefType->getTypee();
  const std::string& typedefName = typedefType->getName();
  /*
   * getFullDeclarationName gives all all the necessary qualifiers without the
   * typedef (p_naked == true).
   */
  std::string localType { typeeType->getFullDeclarationName(true) };
  const TypeItf *rawType = getRawType(typeeType);
  const FunctionType *functionType = rawType->asFunctionType();
  bool isRawTypeFunctionType = functionType != nullptr;
  ctemplate::TemplateDictionary *typeDefDict = m_rootDictionary->AddSectionDictionary(GENERATED_TYPE_SIMPLE_TYPEDEF_SECTION);
  typeDefDict->SetValue(GENERATED_TYPE_SIMPLE_TYPEDEF_GUARD_NAME_NAME, typedefName);

  if(!isRawTypeFunctionType)
  {
    if (rawType->getName().empty())
    {
      localType += std::string{" "} + getAnonymousName(rawType);
    }
    typeDefDict->SetValue(GENERATED_TYPE_SIMPLE_TYPEDEF_TYPED_VAR, typedefName);
  }
  else
  {
    generateDeclarationOfUsedType(m_rootDictionary, functionType, false);
    localType += typedefName;
    localType += functionType->getDeclarationPostfix();
    /*
     * For function type we do not fill GENERATED_TYPE_SIMPLE_TYPEDEF_TYPED_VAR and use we
     * GENERATED_TYPE_SIMPLE_TYPEDEF_TYPEE_VAR to generate the full typedef string. This is because
     * the form 'typedef TYPEE TYPEDEF' doesn't make sense for function pointer typedef declaration
     * i.e. 'rv (*typedetType)(parameter)'
     */
  }
  typeDefDict->SetValue(GENERATED_TYPE_SIMPLE_TYPEDEF_TYPEE_VAR, localType);
}

void CodeGeneratorCTemplate::generateEnum(const TypeItf* p_type)
{
  const Enum* enumType = p_type->asEnum();
  if(!enumType)
  {
    return;
  }
  std::unique_ptr<Enum> copyEnum = std::make_unique<Enum>(*enumType);
  if(enumType->getValues().empty())
  {
    std::string dummyAttr = enumType->getName();
    dummyAttr.push_back('_');
    dummyAttr.append("dummy");
    copyEnum->addEnumValue(0, dummyAttr);
    enumType = copyEnum.get();
  }

  /*
   * First generate the typedef if any. It is very important to do so because
   * we might see a type first without the typedef coming and then the same
   * with the typedef coming depending on how things have been parsed.
   */
  generateSimpleTypeDef(p_type);
  if(m_generatedTypeEnumSection.find(enumType) != m_generatedTypeEnumSection.end())
  {
    return;
  }
  m_generatedTypeEnumSection.emplace(enumType);

  std::string localTypeName { p_type->getName() };
  if(localTypeName.empty())
  {
    localTypeName = getAnonymousName(enumType);
  }
  ctemplate::TemplateDictionary* enumSection = m_rootDictionary->AddSectionDictionary(GENERATED_TYPE_ENUM_SECTION);
  enumSection->SetValue(GENERATED_TYPE_ENUM_NAME_VAR, localTypeName);
  for(const auto& enumVal : enumType->getValues())
  {
    ctemplate::TemplateDictionary *curVal = enumSection->AddSectionDictionary(GENERATED_TYPE_ENUM_VALUE_SECTION);
    curVal->SetValue(GENERATED_TYPE_ENUM_VALUE_VALUE_VAR, std::to_string(enumVal.first));
    curVal->SetValue(GENERATED_TYPE_ENUM_VALUE_NAME_VAR, enumVal.second);
  }
}
