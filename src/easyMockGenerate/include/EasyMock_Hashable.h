/*!
 * \file
 *
 * \brief Contains the implementation of containers using pointers to hashable objects.
 *
 * Any class that wants to be able to use any of the set or map defined in thie file (e.g. ::EasyMock::HashablePointerMap) must
 * inherit from ::EasyMock::Hashable.
 */
#ifndef EASYMOCK_HASHABLE_H
#define EASYMOCK_HASHABLE_H

#include <cstddef>
#include <map>
#include <unordered_map>
#include <unordered_set>

#include <type_traits>

namespace EasyMock {

  /*!
   * \brief Defines the interface that every EasyMock hashable object must implement.
   */
  struct Hashable {
    /*!
     * \brief Generates a unique hash of this object.
     *
     * \return A unique hash for this object.
     */
    [[nodiscard]] virtual std::size_t getHash() const = 0;

    virtual ~Hashable() = default;
  };

  /*!
   * \brief Struct used to get the hash of an ::EasyMock::Hashable object pointer.
   */
  template<typename T>
  struct HashableHash {
    inline size_t operator()(const T &pointer) const {
      static_assert(std::is_pointer<T>::value, "The template parameter must be a pointer");
      static_assert(std::is_base_of<Hashable, typename std::remove_pointer<T>::type>::value,
                    "The template parameter must inherit from EasyMock_Hashable");
      return pointer->getHash();
    }
  };

  /*!
   * \brief Struct used to get the hash of an ::EasyMock::Hashable object pointer.
   */
  template<typename T>
  struct EasyMock_HashableHashEqualTo {
    inline bool operator()(const T &lhs, const T &rhs) const {
      static_assert(std::is_pointer<T>::value, "The template parameter must be a pointer");
      return *lhs == *rhs;
    }
  };

  /*!
   * \brief Templated class to be used to declare a ::EasyMock::HashablePointerMap.
   *
   * A ::EasyMock::HashablePointerMap has the same functionality as a std::map
   *
   * \tparam K The key type of the map. It must inherit from ::EasyMock::Hashable.
   * \tparam T The value type of the map.
   */
  template<typename K, typename T>
  class HashablePointerMap : public std::map<K, T, HashableHash<K>, EasyMock_HashableHashEqualTo<K>>
  {};

  /*!
   * \brief Templated class to be used to declare a ::EasyMock::HashablePointerUnordereddMap.
   *
   * A ::EasyMock::HashablePointerUnordereddMap has the same functionality as a std::unordered_map
   *
   * \tparam K The key type of the unordered map. It must inherit from ::EasyMock::Hashable.
   * \tparam T The value type of the map.
   */
  template<typename K, typename T>
  class HashablePointerUnordereddMap : public std::unordered_map<K, T, HashableHash<K>, EasyMock_HashableHashEqualTo<K>>
  {};

  /*!
   * \brief Templated class to be used to declare a ::EasyMock::HashablePointerUnordereddSet.
   *
   * A ::EasyMock::HashablePointerUnordereddSet has the same functionality as a std::unordered_set
   *
   * \tparam K The key type of the unordered set. It must inherit from ::EasyMock::Hashable.
   */
  template<typename K>
  class HashablePointerUnordereddSet : public std::unordered_set<K, HashableHash<K>, EasyMock_HashableHashEqualTo<K>>
  {};

  /*!
   * \brief hash_value function called by boost for the EasyMock classes
   *
   * Thanks to this templated function and the fact that all the EasyMock classes
   * implement getHash. We can have such call:
   *
   * \code{.cpp}
   * boost::hash_combine(seed, *m_type); //m_elem is a TypeItf*
   * boost::hash_combine(seed, m_elem); //m_elem is a AutocleanVector;
   * \endcode
   *
   * I.E. The hash_value function is automatically generated by the compiler for every class inheriting from
   * ::EasyMock::Hashable object.
   */
  template<typename T>
  std::size_t hash_value(const T &t) {
    return t.getHash();
  }

}

#endif /* EASYMOCK_HASHABLE_H */
